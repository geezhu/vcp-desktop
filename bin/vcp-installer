#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "${SCRIPT_DIR}/.." && pwd)"
VERSION="0.0.0-dev"

for version_path in \
  "${ROOT_DIR}/VERSION" \
  "${SCRIPT_DIR}/../share/vcp-installer/VERSION"; do
  if [ -f "${version_path}" ]; then
    VERSION="$(tr -d '[:space:]' < "${version_path}")"
    break
  fi
done

MODE="auto"
HEADLESS=0
DRY_RUN=0
AUTO_APPROVE=0
SIMULATE_GUI_STEP=0
NO_START_AFTER_INIT=0
STARTUP_DELAY="2"
START_AFTER_INSTALL=0
SKIP_NODE_INSTALL=0
SKIP_PYTHON_INSTALL=0
INSTALL_PLUGIN_PYTHON_DEPS=0
INSTALL_PLUGIN_MANIFEST_DEPS=0
STRICT_DEPENDENCIES=0
FORCE_CONFIG_REWRITE=0
INSTALL_COMPONENTS_ARG="all"
RUNTIME_MODE="portable"
RUNTIME_MODE_CLI_SET=0
RUNTIME_MANIFEST_ARG="${VCP_RUNTIME_MANIFEST:-}"
RESET_RUNTIME=0
INIT_RESUME_MODE=0
ALLOW_SYSTEM_INTEGRATION=0

VCP_API_URL_ARG="${VCP_API_URL:-}"
VCP_API_KEY_ARG="${VCP_API_KEY:-}"
VCP_PORT_ARG="${VCP_PORT:-}"
VCP_KEY_ARG="${VCP_KEY:-}"
ADMIN_USER_ARG="${VCP_ADMIN_USER:-}"
ADMIN_PASSWORD_ARG="${VCP_ADMIN_PASSWORD:-}"
CHAT_SERVER_URL_ARG="${VCP_CHAT_SERVER_URL:-}"
CHAT_API_KEY_ARG="${VCP_CHAT_API_KEY:-}"
CHAT_LOG_URL_ARG="${VCP_CHAT_LOG_URL:-}"
CHAT_LOG_KEY_ARG="${VCP_CHAT_LOG_KEY:-}"

WORKSPACE_ROOT_ARG=""
BACKEND_CWD_ARG=""
BACKEND_CMD_ARG=""
CHAT_CWD_ARG=""
CHAT_CMD_ARG=""

WORKSPACE_ROOT_VAL=""
BACKEND_CWD_VAL=""
BACKEND_CMD_VAL=""
CHAT_CWD_VAL=""
CHAT_CMD_VAL=""

COMMAND="auto"
SESSION_ID=""
SESSION_FILE=""
REPORT_DIR=""
INSTALL_REPORT_JSON=""
INSTALL_REPORT_MD=""

INSTALL_STATUS="success"
INSTALL_WARNINGS=()
INSTALL_ERRORS=()
INSTALL_STEPS=()
DEPENDENCY_MATRIX_ROWS=()
DEPENDENCY_MATRIX_REPORT_MD=""
INSTALL_TOOLBOX_ENABLED=1
INSTALL_CHAT_ENABLED=1
RUNTIME_WRAPPER_PATH=""
RUNTIME_MANIFEST_PATH_RESOLVED=""
RUNTIME_MANIFEST_SOURCE=""
RUNTIME_MANIFEST_LOCK_FILE=""
RUNTIME_ENTRIES=()
RUNTIME_GLOBAL_MUTATION_SAFE=1

resolve_installer_home() {
  if [ -n "${VCP_INSTALLER_HOME:-}" ]; then
    printf '%s\n' "${VCP_INSTALLER_HOME}"
    return
  fi

  if [ -n "${XDG_DATA_HOME:-}" ]; then
    printf '%s/vcpinstallergui\n' "${XDG_DATA_HOME}"
    return
  fi

  if [ -n "${HOME:-}" ]; then
    printf '%s/.local/share/vcpinstallergui\n' "${HOME}"
    return
  fi

  printf '%s/.vcpinstallergui\n' "${ROOT_DIR}"
}

detect_platform_tag() {
  local os
  local arch
  os="$(uname -s 2>/dev/null | tr '[:upper:]' '[:lower:]')"
  arch="$(uname -m 2>/dev/null)"

  case "${arch}" in
    x86_64|amd64)
      arch="x86_64"
      ;;
    aarch64|arm64)
      arch="aarch64"
      ;;
  esac

  if [ -z "${os}" ]; then
    os="linux"
  fi
  if [ -z "${arch}" ]; then
    arch="x86_64"
  fi

  printf '%s-%s\n' "${os}" "${arch}"
}

INSTALLER_HOME="$(resolve_installer_home)"
STATE_DIR="${VCP_INSTALLER_STATE_DIR:-${INSTALLER_HOME}/state}"
CONFIG_FILE="${INSTALLER_HOME}/launcher-config.env"
RUN_DIR="${INSTALLER_HOME}/run"
LOG_DIR="${INSTALLER_HOME}/logs"
PLATFORM_TAG="$(detect_platform_tag)"
RUNTIME_ROOT="${INSTALLER_HOME}/runtime"
RUNTIME_CACHE_DIR="${RUNTIME_ROOT}/cache"
RUNTIME_MANIFESTS_DIR="${RUNTIME_ROOT}/manifests"
RUNTIME_COMPONENTS_DIR="${RUNTIME_ROOT}/components"
RUNTIME_BIN_DIR="${RUNTIME_ROOT}/bin"
RUNTIME_STATE_FILE="${RUNTIME_ROOT}/runtime-state.env"
RUNTIME_STATUS_JSON="${RUNTIME_ROOT}/runtime-status.json"
SYSTEM_INTEGRATION_AUDIT_FILE="${INSTALLER_HOME}/reports/system-integration-audit.log"
DEFAULT_RUNTIME_MANIFEST="${ROOT_DIR}/manifests/runtime-manifest-${PLATFORM_TAG}.txt"

mkdir -p \
  "${INSTALLER_HOME}" \
  "${STATE_DIR}" \
  "${RUN_DIR}" \
  "${LOG_DIR}" \
  "${RUNTIME_ROOT}" \
  "${RUNTIME_CACHE_DIR}" \
  "${RUNTIME_MANIFESTS_DIR}" \
  "${RUNTIME_COMPONENTS_DIR}" \
  "${RUNTIME_BIN_DIR}"

timestamp() {
  date -u +"%Y-%m-%dT%H:%M:%SZ"
}

log() {
  local level="$1"
  shift
  printf '%s [%s] %s\n' "$(timestamp)" "${level}" "$*"
}

usage() {
  cat <<'EOF'
VCPInstallerGUI installer

Usage:
  vcp-installer [command] [options]

Commands:
  init                    Run initialization wizard and save launch config
  start                   Start backend and VCPChat with saved config
  stop                    Stop backend and VCPChat started by installer
  status                  Show launcher and process status
  reset                   Remove saved launcher config and runtime state
  install                 Run component install/configuration flow
  resume                  Resume previous install session (state-based)

Options:
  --cli                   Force CLI mode
  --gui                   Force GUI mode
  --auto                  Auto detect mode (default)
  --headless              Headless mode (CLI only)
  --dry-run               Do not run mutation steps
  --yes                   Non-interactive mode
  --simulate-gui-step     Simulate a GUI required step (for testing)
  --no-start-after-init   Initialize only, do not auto-start services
  --runtime-mode <mode>   Runtime mode: portable|system (default portable)
  --runtime-manifest <p>  Runtime manifest path/URL for portable bootstrap
  --allow-system-integration
                           Confirm system mode usage and write audit record
  --reset-runtime         With reset, also remove runtime cache/components
  --workspace-root <dir>  Workspace root path (for init)
  --components <value>    Install targets: all|toolbox|chat|toolbox,chat
  --skip-node-install     Skip npm dependency installation
  --skip-python-install   Skip pip dependency installation
  --install-plugin-python-deps
                           Install Plugin/**/requirements.txt for selected components
  --install-plugin-manifest-deps
                           Install dependencies declared in Plugin/**/plugin-manifest.json
  --strict-dependencies   Treat missing required commands as install errors
  --overwrite-config      Rewrite generated config files if already present
  --start-after-install   Start backend/chat after install flow
  --vcp-api-url <url>     Value for VCPToolBox API_URL
  --vcp-api-key <key>     Value for VCPToolBox API_Key
  --vcp-port <port>       Value for VCPToolBox PORT (default 6005)
  --vcp-key <key>         Value for VCPToolBox VCP_Key
  --admin-user <name>     Value for VCPToolBox AdminUsername
  --admin-password <pwd>  Value for VCPToolBox AdminPassword
  --chat-server-url <url> Value for VCPChat settings.vcpServerUrl
  --chat-api-key <key>    Value for VCPChat settings.vcpApiKey
  --chat-log-url <url>    Value for VCPChat settings.vcpLogUrl
  --chat-log-key <key>    Value for VCPChat settings.vcpLogKey
  --backend-cwd <dir>     Backend working directory
  --backend-cmd <cmd>     Backend startup command
  --chat-cwd <dir>        VCPChat working directory
  --chat-cmd <cmd>        VCPChat startup command
  --startup-delay <sec>   Delay between backend and chat startup
  --version               Print installer version
  --help                  Print this help

Examples:
  vcp-installer
  vcp-installer install --cli --yes --components all --install-plugin-manifest-deps
  vcp-installer init --gui
  vcp-installer init --cli --yes --runtime-mode portable --runtime-manifest ./manifests/runtime-manifest-linux-x86_64.txt --workspace-root ~/vcp --backend-cmd "node server.js" --chat-cmd "npm run start"
  vcp-installer init --cli --yes --runtime-mode system --allow-system-integration --workspace-root ~/vcp
  vcp-installer start
  vcp-installer stop
  vcp-installer status
EOF
}

require_cmd_or_warn() {
  local cmd="$1"
  if command -v "${cmd}" >/dev/null 2>&1; then
    local line
    line="$("${cmd}" --version 2>/dev/null | head -n 1 || true)"
    if [ -n "${line}" ]; then
      log INFO "Detected ${cmd}: ${line}"
    else
      log INFO "Detected ${cmd}"
    fi
  else
    log WARN "Missing dependency: ${cmd}"
  fi
}

emit_gui_required_block() {
  cat <<EOF
GUI_REQUIRED
step_id: S45_GUI_REQUIRED
reason: This step requires an interactive GUI action.
user_action: Open GUI session and complete the required dialog.
completion_criteria: GUI action finished and confirmed.
resume_command: ${0} resume --cli
EOF
}

emit_init_required_block() {
  cat <<EOF
INIT_REQUIRED
step_id: S20_INITIALIZE
reason: Launcher config is missing and headless mode cannot open GUI wizard.
user_action: Run initialization with explicit commands.
completion_criteria: ${CONFIG_FILE} exists with backend/chat commands.
continue_command: ${0} init --cli --yes --backend-cwd <dir> --backend-cmd <cmd> --chat-cwd <dir> --chat-cmd <cmd>
EOF
}

write_state() {
  local session_file="$1"
  local step_id="$2"
  local status="$3"
  local detail="$4"
  cat > "${session_file}" <<EOF
{
  "session_id": "${SESSION_ID}",
  "mode": "${MODE}",
  "headless": ${HEADLESS},
  "dry_run": ${DRY_RUN},
  "step_id": "${step_id}",
  "status": "${status}",
  "detail": "${detail}",
  "updated_at": "$(timestamp)"
}
EOF
}

runtime_init_profile_file() {
  printf '%s/init-session-%s.env\n' "${STATE_DIR}" "${SESSION_ID}"
}

save_init_profile_snapshot() {
  local profile_file
  profile_file="$(runtime_init_profile_file)"

  if [ "${DRY_RUN}" -eq 1 ]; then
    log INFO "Dry-run: would persist init snapshot to ${profile_file}"
    return
  fi

  {
    printf 'WORKSPACE_ROOT_VAL=%q\n' "${WORKSPACE_ROOT_VAL}"
    printf 'BACKEND_CWD_VAL=%q\n' "${BACKEND_CWD_VAL}"
    printf 'BACKEND_CMD_VAL=%q\n' "${BACKEND_CMD_VAL}"
    printf 'CHAT_CWD_VAL=%q\n' "${CHAT_CWD_VAL}"
    printf 'CHAT_CMD_VAL=%q\n' "${CHAT_CMD_VAL}"
    printf 'STARTUP_DELAY=%q\n' "${STARTUP_DELAY}"
    printf 'RUNTIME_MODE=%q\n' "${RUNTIME_MODE}"
    printf 'RUNTIME_MANIFEST_ARG=%q\n' "${RUNTIME_MANIFEST_ARG}"
    printf 'ALLOW_SYSTEM_INTEGRATION=%q\n' "${ALLOW_SYSTEM_INTEGRATION}"
    printf 'NO_START_AFTER_INIT=%q\n' "${NO_START_AFTER_INIT}"
  } > "${profile_file}"
}

load_init_profile_snapshot() {
  local profile_file
  profile_file="$(runtime_init_profile_file)"
  if [ ! -f "${profile_file}" ]; then
    return 1
  fi

  # shellcheck disable=SC1090
  source "${profile_file}"
  return 0
}

read_state_json_field() {
  local state_file="$1"
  local field_name="$2"
  if [ ! -f "${state_file}" ]; then
    return
  fi
  sed -n "s/.*\"${field_name}\": \"\\([^\"]*\\)\".*/\\1/p" "${state_file}" | head -n 1
}

is_url_like() {
  case "$1" in
    http://*|https://*|file://*)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

validate_runtime_mode() {
  case "${RUNTIME_MODE}" in
    portable|system)
      return 0
      ;;
    *)
      echo "Invalid --runtime-mode: ${RUNTIME_MODE} (supported: portable|system)" >&2
      return 1
      ;;
  esac
}

record_system_integration_audit() {
  local reason="$1"
  if [ "${DRY_RUN}" -eq 1 ]; then
    log INFO "Dry-run: would write system integration audit record (${reason})"
    return
  fi

  mkdir -p "$(dirname "${SYSTEM_INTEGRATION_AUDIT_FILE}")"
  printf '%s session=%s mode=system reason=%s workspace=%s\n' \
    "$(timestamp)" \
    "${SESSION_ID}" \
    "${reason}" \
    "${WORKSPACE_ROOT_VAL:-<unset>}" >> "${SYSTEM_INTEGRATION_AUDIT_FILE}"
}

confirm_system_integration_mode() {
  local answer

  if [ "${RUNTIME_MODE}" != "system" ]; then
    return 0
  fi

  if [ "${ALLOW_SYSTEM_INTEGRATION}" -eq 1 ]; then
    record_system_integration_audit "explicit-flag"
    return 0
  fi

  if [ "${HEADLESS}" -eq 1 ] || [ "${AUTO_APPROVE}" -eq 1 ]; then
    log ERROR "System mode requires explicit --allow-system-integration in non-interactive/headless run."
    return 1
  fi

  read -r -p "System mode may integrate with global environment. Continue? [y/N]: " answer || true
  case "${answer}" in
    y|Y|yes|YES)
      ALLOW_SYSTEM_INTEGRATION=1
      record_system_integration_audit "interactive-confirmed"
      return 0
      ;;
    *)
      log ERROR "System mode not confirmed by user."
      return 1
      ;;
  esac
}

join_by_colon() {
  local joined=""
  local item
  for item in "$@"; do
    if [ -z "${item}" ]; then
      continue
    fi
    if [ -z "${joined}" ]; then
      joined="${item}"
    else
      joined="${joined}:${item}"
    fi
  done
  printf '%s' "${joined}"
}

calc_sha256() {
  local file_path="$1"
  sha256sum "${file_path}" | awk '{print $1}'
}

verify_sha256_file() {
  local file_path="$1"
  local expected_sha="$2"
  local actual_sha

  if [ ! -f "${file_path}" ]; then
    return 1
  fi

  actual_sha="$(calc_sha256 "${file_path}")"
  if [ "${actual_sha}" = "${expected_sha}" ]; then
    return 0
  fi
  return 1
}

require_download_client() {
  if command -v curl >/dev/null 2>&1; then
    return 0
  fi
  if command -v wget >/dev/null 2>&1; then
    return 0
  fi
  log ERROR "Neither curl nor wget is available for runtime download."
  return 1
}

download_url_with_resume() {
  local url="$1"
  local target="$2"
  local tmp="${target}.part"
  local rc=0

  mkdir -p "$(dirname "${target}")"

  if command -v curl >/dev/null 2>&1; then
    if [ -f "${tmp}" ]; then
      curl -fsSL --retry 3 --retry-delay 2 --connect-timeout 20 -C - -o "${tmp}" "${url}" || rc=$?
    else
      curl -fsSL --retry 3 --retry-delay 2 --connect-timeout 20 -o "${tmp}" "${url}" || rc=$?
    fi
  elif command -v wget >/dev/null 2>&1; then
    wget --tries=3 --timeout=20 -c -O "${tmp}" "${url}" || rc=$?
  else
    return 1
  fi

  if [ "${rc}" -ne 0 ]; then
    return "${rc}"
  fi

  mv "${tmp}" "${target}"
}

resolve_runtime_manifest_path() {
  local manifest_ref
  local resolved_path

  manifest_ref="${RUNTIME_MANIFEST_ARG:-${DEFAULT_RUNTIME_MANIFEST}}"
  if [ -z "${manifest_ref}" ]; then
    log ERROR "Runtime manifest is not provided. Use --runtime-manifest <path_or_url>."
    return 1
  fi

  if is_url_like "${manifest_ref}"; then
    if [ "${DRY_RUN}" -eq 1 ]; then
      log ERROR "Dry-run with URL manifest is not supported. Provide a local file with --runtime-manifest."
      return 1
    fi
    require_download_client || return 1
    resolved_path="${RUNTIME_MANIFESTS_DIR}/runtime-manifest-${SESSION_ID}.txt"
    log INFO "Downloading runtime manifest from ${manifest_ref}"
    if ! download_url_with_resume "${manifest_ref}" "${resolved_path}"; then
      log ERROR "Failed to download runtime manifest from ${manifest_ref}"
      return 1
    fi
  else
    resolved_path="${manifest_ref}"
    if [ ! -f "${resolved_path}" ]; then
      log ERROR "Runtime manifest file not found: ${resolved_path}"
      return 1
    fi
  fi

  RUNTIME_MANIFEST_SOURCE="${manifest_ref}"
  RUNTIME_MANIFEST_PATH_RESOLVED="${resolved_path}"
  return 0
}

validate_runtime_manifest_record() {
  local line_no="$1"
  local name="$2"
  local version="$3"
  local platform="$4"
  local url_primary="$5"
  local sha256="$6"
  local signature="${7:-}"

  if ! printf '%s' "${name}" | grep -Eq '^[A-Za-z0-9._-]+$'; then
    log ERROR "Manifest line ${line_no}: invalid artifact name '${name}'"
    return 1
  fi
  if [ -z "${version}" ]; then
    log ERROR "Manifest line ${line_no}: empty version"
    return 1
  fi
  if [ -z "${platform}" ]; then
    log ERROR "Manifest line ${line_no}: empty platform"
    return 1
  fi
  if [ -z "${url_primary}" ] || [ "${url_primary}" = "-" ]; then
    log ERROR "Manifest line ${line_no}: primary url is required"
    return 1
  fi
  if ! is_url_like "${url_primary}"; then
    log ERROR "Manifest line ${line_no}: primary url must be http(s):// or file://"
    return 1
  fi
  if ! printf '%s' "${sha256}" | grep -Eq '^[a-fA-F0-9]{64}$'; then
    log ERROR "Manifest line ${line_no}: invalid sha256 '${sha256}'"
    return 1
  fi
  if [ -n "${signature}" ] && [ "${signature}" != "-" ] && ! is_url_like "${signature}"; then
    log ERROR "Manifest line ${line_no}: signature must be http(s):// or file:// when provided"
    return 1
  fi
  return 0
}

parse_runtime_manifest() {
  local manifest_file="$1"
  local line
  local line_no=0
  local record_type
  local name
  local version
  local platform
  local url_primary
  local url_mirror
  local sha256
  local signature
  local extra
  local manifest_version=""

  RUNTIME_ENTRIES=()

  if [ ! -f "${manifest_file}" ]; then
    log ERROR "Runtime manifest does not exist: ${manifest_file}"
    return 1
  fi

  while IFS= read -r line || [ -n "${line}" ]; do
    line_no=$((line_no + 1))
    line="$(printf '%s' "${line}" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
    if [ -z "${line}" ] || [ "${line#\#}" != "${line}" ]; then
      continue
    fi

    IFS='|' read -r record_type name version platform url_primary url_mirror sha256 signature extra <<< "${line}"
    if [ -n "${extra:-}" ]; then
      log ERROR "Manifest line ${line_no}: too many fields"
      return 1
    fi

    case "${record_type}" in
      manifest_version)
        manifest_version="${name}"
        ;;
      artifact)
        validate_runtime_manifest_record "${line_no}" "${name}" "${version}" "${platform}" "${url_primary}" "${sha256}" "${signature:-}" || return 1
        if [ "${platform}" != "${PLATFORM_TAG}" ] && [ "${platform}" != "all" ]; then
          continue
        fi
        if [ -z "${url_mirror}" ]; then
          url_mirror="-"
        fi
        if [ -z "${signature}" ]; then
          signature="-"
        fi
        RUNTIME_ENTRIES+=("${name}|${version}|${platform}|${url_primary}|${url_mirror}|${sha256}|${signature}")
        ;;
      *)
        log ERROR "Manifest line ${line_no}: unknown record type '${record_type}'"
        return 1
        ;;
    esac
  done < "${manifest_file}"

  if [ -z "${manifest_version}" ]; then
    log ERROR "Manifest is missing manifest_version record"
    return 1
  fi

  if [ "${#RUNTIME_ENTRIES[@]}" -eq 0 ]; then
    log ERROR "Manifest has no artifact entries for platform ${PLATFORM_TAG}"
    return 1
  fi

  return 0
}

runtime_archive_path_for_entry() {
  local name="$1"
  local version="$2"
  local platform="$3"
  local url="$4"
  local archive_name
  archive_name="$(basename "${url%%\?*}")"
  archive_name="$(printf '%s' "${archive_name}" | tr -cd 'A-Za-z0-9._-')"
  if [ -z "${archive_name}" ]; then
    archive_name="${name}-${version}.archive"
  fi
  printf '%s/%s-%s-%s-%s\n' "${RUNTIME_CACHE_DIR}" "${name}" "${version}" "${platform}" "${archive_name}"
}

RUNTIME_RESOLVED_ENTRIES=()

fetch_runtime_entries() {
  local row
  local name
  local version
  local platform
  local url_primary
  local url_mirror
  local sha256
  local signature
  local archive_path
  local source_used

  RUNTIME_RESOLVED_ENTRIES=()

  for row in "${RUNTIME_ENTRIES[@]}"; do
    IFS='|' read -r name version platform url_primary url_mirror sha256 signature <<< "${row}"
    archive_path="$(runtime_archive_path_for_entry "${name}" "${version}" "${platform}" "${url_primary}")"
    source_used="${url_primary}"

    if [ "${DRY_RUN}" -eq 1 ]; then
      log INFO "Dry-run: would download runtime artifact ${name}@${version} -> ${archive_path}"
      RUNTIME_RESOLVED_ENTRIES+=("${name}|${version}|${platform}|${url_primary}|${url_mirror}|${sha256}|${signature}|${archive_path}|dry-run")
      continue
    fi

    if [ -f "${archive_path}" ] && verify_sha256_file "${archive_path}" "${sha256}"; then
      log INFO "Runtime cache hit: ${archive_path}"
      RUNTIME_RESOLVED_ENTRIES+=("${name}|${version}|${platform}|${url_primary}|${url_mirror}|${sha256}|${signature}|${archive_path}|cache")
      continue
    fi

    if ! download_url_with_resume "${url_primary}" "${archive_path}"; then
      if [ -n "${url_mirror}" ] && [ "${url_mirror}" != "-" ]; then
        log WARN "Primary runtime source failed for ${name}@${version}, fallback to mirror."
        if ! download_url_with_resume "${url_mirror}" "${archive_path}"; then
          log ERROR "Failed to download runtime artifact from both primary and mirror: ${name}@${version}"
          return 1
        fi
        source_used="${url_mirror}"
      else
        log ERROR "Failed to download runtime artifact: ${name}@${version}"
        return 1
      fi
    fi

    RUNTIME_RESOLVED_ENTRIES+=("${name}|${version}|${platform}|${url_primary}|${url_mirror}|${sha256}|${signature}|${archive_path}|${source_used}")
  done

  return 0
}

verify_runtime_entries() {
  local row
  local name
  local version
  local platform
  local url_primary
  local url_mirror
  local sha256
  local signature
  local archive_path
  local source_used

  if [ "${DRY_RUN}" -eq 1 ]; then
    log INFO "Dry-run: skipping runtime checksum verification"
    return 0
  fi

  for row in "${RUNTIME_RESOLVED_ENTRIES[@]}"; do
    IFS='|' read -r name version platform url_primary url_mirror sha256 signature archive_path source_used <<< "${row}"
    if ! verify_sha256_file "${archive_path}" "${sha256}"; then
      log ERROR "Runtime sha256 mismatch: ${name}@${version} (${archive_path})"
      return 1
    fi
    log INFO "Runtime checksum verified: ${name}@${version}"
  done

  return 0
}

extract_runtime_archive() {
  local archive_path="$1"
  local target_dir="$2"

  case "${archive_path}" in
    *.tar.gz|*.tgz)
      tar -xzf "${archive_path}" -C "${target_dir}"
      ;;
    *.tar.xz)
      tar -xJf "${archive_path}" -C "${target_dir}"
      ;;
    *.zip)
      if ! command -v unzip >/dev/null 2>&1; then
        log ERROR "unzip is required for archive: ${archive_path}"
        return 1
      fi
      unzip -q "${archive_path}" -d "${target_dir}"
      ;;
    *)
      cp "${archive_path}" "${target_dir}/"
      ;;
  esac
}

write_runtime_status_report() {
  local mode="$1"
  local now_iso
  local idx
  local row
  local name
  local version
  local platform
  local url_primary
  local url_mirror
  local sha256
  local signature
  local archive_path
  local source_used

  now_iso="$(timestamp)"
  mkdir -p "$(dirname "${RUNTIME_STATUS_JSON}")"

  {
    printf '{\n'
    printf '  "generated_at": "%s",\n' "$(json_escape "${now_iso}")"
    printf '  "mode": "%s",\n' "$(json_escape "${mode}")"
    printf '  "platform": "%s",\n' "$(json_escape "${PLATFORM_TAG}")"
    printf '  "manifest_source": "%s",\n' "$(json_escape "${RUNTIME_MANIFEST_SOURCE}")"
    printf '  "manifest_path": "%s",\n' "$(json_escape "${RUNTIME_MANIFEST_PATH_RESOLVED}")"
    printf '  "wrapper_path": "%s",\n' "$(json_escape "${RUNTIME_WRAPPER_PATH}")"
    printf '  "global_mutation_safe": true,\n'
    printf '  "artifacts": [\n'
    for idx in "${!RUNTIME_RESOLVED_ENTRIES[@]}"; do
      row="${RUNTIME_RESOLVED_ENTRIES[$idx]}"
      IFS='|' read -r name version platform url_primary url_mirror sha256 signature archive_path source_used <<< "${row}"
      printf '    {"name":"%s","version":"%s","platform":"%s","sha256":"%s","source":"%s","cache":"%s"}' \
        "$(json_escape "${name}")" \
        "$(json_escape "${version}")" \
        "$(json_escape "${platform}")" \
        "$(json_escape "${sha256}")" \
        "$(json_escape "${source_used}")" \
        "$(json_escape "${archive_path}")"
      if [ "${idx}" -lt "$((${#RUNTIME_RESOLVED_ENTRIES[@]} - 1))" ]; then
        printf ','
      fi
      printf '\n'
    done
    printf '  ]\n'
    printf '}\n'
  } > "${RUNTIME_STATUS_JSON}"
}

prepare_runtime_entries() {
  local row
  local name
  local version
  local platform
  local url_primary
  local url_mirror
  local sha256
  local signature
  local archive_path
  local source_used
  local component_dir
  local bin_dir
  local lib_dir
  local runtime_bin_paths=()
  local runtime_lib_paths=()
  local path_prefix
  local lib_prefix
  local marker_file

  if [ "${DRY_RUN}" -eq 1 ]; then
    RUNTIME_WRAPPER_PATH="${RUNTIME_BIN_DIR}/vcp-runtime-exec"
    log INFO "Dry-run: would prepare runtime wrapper ${RUNTIME_WRAPPER_PATH}"
    return 0
  fi

  mkdir -p "${RUNTIME_COMPONENTS_DIR}" "${RUNTIME_BIN_DIR}"

  for row in "${RUNTIME_RESOLVED_ENTRIES[@]}"; do
    IFS='|' read -r name version platform url_primary url_mirror sha256 signature archive_path source_used <<< "${row}"
    component_dir="${RUNTIME_COMPONENTS_DIR}/${name}/${version}"
    marker_file="${component_dir}/.ready-sha256"

    if [ -f "${marker_file}" ] && [ "$(cat "${marker_file}" 2>/dev/null || true)" = "${sha256}" ]; then
      log INFO "Runtime component already prepared: ${name}@${version}"
    else
      rm -rf "${component_dir}"
      mkdir -p "${component_dir}"
      extract_runtime_archive "${archive_path}" "${component_dir}" || return 1
      printf '%s\n' "${sha256}" > "${marker_file}"
    fi

    bin_dir=""
    if [ -d "${component_dir}/bin" ]; then
      bin_dir="${component_dir}/bin"
    else
      bin_dir="$(find "${component_dir}" -maxdepth 4 -type d -name bin | head -n 1 || true)"
    fi
    if [ -n "${bin_dir}" ]; then
      runtime_bin_paths+=("${bin_dir}")
    fi

    lib_dir=""
    lib_dir="$(find "${component_dir}" -maxdepth 4 -type d \( -name lib -o -name lib64 \) | head -n 1 || true)"
    if [ -n "${lib_dir}" ]; then
      runtime_lib_paths+=("${lib_dir}")
    fi
  done

  path_prefix="$(join_by_colon "${runtime_bin_paths[@]}")"
  lib_prefix="$(join_by_colon "${runtime_lib_paths[@]}")"
  RUNTIME_WRAPPER_PATH="${RUNTIME_BIN_DIR}/vcp-runtime-exec"

  {
    printf '#!/usr/bin/env bash\n'
    printf 'set -euo pipefail\n'
    printf 'PATH_PREFIX=%q\n' "${path_prefix}"
    printf 'LIB_PREFIX=%q\n' "${lib_prefix}"
    printf 'if [ -n "${PATH_PREFIX}" ]; then\n'
    printf '  export PATH="${PATH_PREFIX}:${PATH}"\n'
    printf 'fi\n'
    printf 'if [ -n "${LIB_PREFIX}" ]; then\n'
    printf '  export LD_LIBRARY_PATH="${LIB_PREFIX}:${LD_LIBRARY_PATH:-}"\n'
    printf 'fi\n'
    printf 'if [ "${1:-}" = "--command" ]; then\n'
    printf '  shift\n'
    printf 'fi\n'
    printf 'if [ "$#" -eq 0 ]; then\n'
    printf '  echo "Usage: $0 --command <command-string>" >&2\n'
    printf '  exit 2\n'
    printf 'fi\n'
    printf 'exec bash -lc "$*"\n'
  } > "${RUNTIME_WRAPPER_PATH}"
  chmod +x "${RUNTIME_WRAPPER_PATH}"

  {
    printf 'RUNTIME_MODE=%q\n' "${RUNTIME_MODE}"
    printf 'RUNTIME_PLATFORM=%q\n' "${PLATFORM_TAG}"
    printf 'RUNTIME_MANIFEST_SOURCE=%q\n' "${RUNTIME_MANIFEST_SOURCE}"
    printf 'RUNTIME_MANIFEST_PATH=%q\n' "${RUNTIME_MANIFEST_PATH_RESOLVED}"
    printf 'RUNTIME_WRAPPER_PATH=%q\n' "${RUNTIME_WRAPPER_PATH}"
    printf 'RUNTIME_GLOBAL_MUTATION_SAFE=%q\n' "1"
  } > "${RUNTIME_STATE_FILE}"

  write_runtime_status_report "${RUNTIME_MODE}"
  return 0
}

run_runtime_bootstrap() {
  if [ "${RUNTIME_MODE}" != "portable" ]; then
    log INFO "Runtime mode is system; skipping portable runtime bootstrap."
    return 0
  fi

  write_state "${SESSION_FILE}" "S25_RUNTIME_PLAN" "running" "runtime-manifest-resolve"
  if ! resolve_runtime_manifest_path; then
    write_state "${SESSION_FILE}" "S25_RUNTIME_PLAN" "failed" "manifest-resolve-failed"
    return 1
  fi
  if ! parse_runtime_manifest "${RUNTIME_MANIFEST_PATH_RESOLVED}"; then
    write_state "${SESSION_FILE}" "S25_RUNTIME_PLAN" "failed" "manifest-parse-failed"
    return 1
  fi
  if [ "${DRY_RUN}" -eq 0 ]; then
    RUNTIME_MANIFEST_LOCK_FILE="${RUNTIME_MANIFESTS_DIR}/runtime-manifest-${SESSION_ID}.lock.txt"
    cp "${RUNTIME_MANIFEST_PATH_RESOLVED}" "${RUNTIME_MANIFEST_LOCK_FILE}"
  fi
  write_state "${SESSION_FILE}" "S25_RUNTIME_PLAN" "success" "manifest-ready"

  write_state "${SESSION_FILE}" "S26_RUNTIME_FETCH" "running" "runtime-download"
  if ! fetch_runtime_entries; then
    write_state "${SESSION_FILE}" "S26_RUNTIME_FETCH" "failed" "runtime-download-failed"
    return 1
  fi
  write_state "${SESSION_FILE}" "S26_RUNTIME_FETCH" "success" "runtime-downloaded"

  write_state "${SESSION_FILE}" "S27_RUNTIME_VERIFY" "running" "runtime-checksum"
  if ! verify_runtime_entries; then
    write_state "${SESSION_FILE}" "S27_RUNTIME_VERIFY" "failed" "runtime-checksum-failed"
    return 1
  fi
  write_state "${SESSION_FILE}" "S27_RUNTIME_VERIFY" "success" "runtime-verified"

  write_state "${SESSION_FILE}" "S28_RUNTIME_PREPARE" "running" "runtime-prepare"
  if ! prepare_runtime_entries; then
    write_state "${SESSION_FILE}" "S28_RUNTIME_PREPARE" "failed" "runtime-prepare-failed"
    return 1
  fi
  write_state "${SESSION_FILE}" "S28_RUNTIME_PREPARE" "success" "runtime-ready"
  return 0
}

load_runtime_state() {
  if [ ! -f "${RUNTIME_STATE_FILE}" ]; then
    return 1
  fi
  # shellcheck disable=SC1090
  source "${RUNTIME_STATE_FILE}"
  return 0
}

build_runtime_wrapped_command() {
  local wrapper_path="$1"
  local raw_cmd="$2"
  printf '%q --command %q' "${wrapper_path}" "${raw_cmd}"
}

safe_pid_running() {
  local pid="$1"
  if [ -z "${pid}" ]; then
    return 1
  fi
  kill -0 "${pid}" >/dev/null 2>&1
}

detect_workspace_root() {
  if [ -n "${WORKSPACE_ROOT_ARG}" ]; then
    printf '%s\n' "${WORKSPACE_ROOT_ARG}"
    return
  fi

  if [ -n "${VCP_WORKSPACE_ROOT:-}" ]; then
    printf '%s\n' "${VCP_WORKSPACE_ROOT}"
    return
  fi

  local candidate
  candidate="$(cd "${ROOT_DIR}/.." && pwd)"
  if [ -d "${candidate}/VCPToolBox" ] || [ -d "${candidate}/VCPChat" ]; then
    printf '%s\n' "${candidate}"
    return
  fi

  if [ -n "${HOME:-}" ]; then
    printf '%s/vcp\n' "${HOME}"
    return
  fi

  printf '%s\n' "${ROOT_DIR}"
}

add_install_warning() {
  local message="$1"
  INSTALL_WARNINGS+=("${message}")
  if [ "${INSTALL_STATUS}" != "failed" ]; then
    INSTALL_STATUS="warning"
  fi
}

add_install_error() {
  local message="$1"
  INSTALL_ERRORS+=("${message}")
  INSTALL_STATUS="failed"
}

add_install_step() {
  local step_id="$1"
  local status="$2"
  local detail="$3"
  INSTALL_STEPS+=("${step_id}|${status}|${detail}")
}

add_dependency_matrix_row() {
  local component_name="$1"
  local source_type="$2"
  local source_path="$3"
  local dep_type="$4"
  local dep_value="$5"
  DEPENDENCY_MATRIX_ROWS+=("${component_name}|${source_type}|${source_path}|${dep_type}|${dep_value}")
}

append_unique() {
  local array_name="$1"
  local value="$2"
  local item
  local -n arr_ref="${array_name}"

  for item in "${arr_ref[@]}"; do
    if [ "${item}" = "${value}" ]; then
      return 0
    fi
  done
  arr_ref+=("${value}")
}

write_dependency_matrix_report() {
  local matrix_row
  local component_name
  local source_type
  local source_path
  local dep_type
  local dep_value

  if [ "${DRY_RUN}" -eq 1 ]; then
    return
  fi

  if [ "${#DEPENDENCY_MATRIX_ROWS[@]}" -eq 0 ]; then
    return
  fi

  DEPENDENCY_MATRIX_REPORT_MD="${REPORT_DIR}/dependency-matrix-${SESSION_ID}.md"

  {
    printf '# Dependency Matrix Report\n\n'
    printf -- '- Session: `%s`\n' "${SESSION_ID}"
    printf -- '- Generated At (UTC): `%s`\n' "$(timestamp)"
    printf -- '- Rows: `%s`\n\n' "${#DEPENDENCY_MATRIX_ROWS[@]}"
    printf '| Component | Source Type | Source Path | Dependency Type | Value |\n'
    printf '| --- | --- | --- | --- | --- |\n'
    for matrix_row in "${DEPENDENCY_MATRIX_ROWS[@]}"; do
      IFS='|' read -r component_name source_type source_path dep_type dep_value <<< "${matrix_row}"
      printf '| %s | %s | %s | %s | `%s` |\n' \
        "${component_name}" \
        "${source_type}" \
        "${source_path}" \
        "${dep_type}" \
        "${dep_value}"
    done
  } > "${DEPENDENCY_MATRIX_REPORT_MD}"

  log INFO "Dependency matrix report: ${DEPENDENCY_MATRIX_REPORT_MD}"
}

emit_manifest_dependencies() {
  local manifest_file="$1"
  if command -v python3 >/dev/null 2>&1; then
    python3 - "${manifest_file}" <<'PY'
import json
import sys

manifest_path = sys.argv[1]
with open(manifest_path, "r", encoding="utf-8") as fp:
    data = json.load(fp)

deps = data.get("dependencies") or {}
if not isinstance(deps, dict):
    sys.exit(0)

for dep_type in ("npm", "pip", "system"):
    values = deps.get(dep_type, [])
    if isinstance(values, str):
        values = [values]
    if not isinstance(values, list):
        continue
    for raw in values:
        if isinstance(raw, str):
            value = raw.strip()
            if value:
                print(f"{dep_type}|{value}")
PY
    return
  fi

  if command -v node >/dev/null 2>&1; then
    node - "${manifest_file}" <<'NODE'
const fs = require("fs");

const manifestPath = process.argv[2];
const data = JSON.parse(fs.readFileSync(manifestPath, "utf8"));
const deps = data.dependencies || {};

for (const depType of ["npm", "pip", "system"]) {
  let values = deps[depType] ?? [];
  if (typeof values === "string") values = [values];
  if (!Array.isArray(values)) continue;
  for (const raw of values) {
    if (typeof raw !== "string") continue;
    const value = raw.trim();
    if (value) {
      process.stdout.write(`${depType}|${value}\n`);
    }
  }
}
NODE
    return
  fi

  return 127
}

collect_plugin_manifest_dependencies() {
  local component_name="$1"
  local component_dir="$2"
  local npm_array_name="$3"
  local pip_array_name="$4"
  local system_array_name="$5"
  local manifest_count_name="$6"
  local plugin_root="${component_dir}/Plugin"
  local manifest_file
  local manifest_files=()
  local parsed_rows
  local parse_err
  local dep_row
  local dep_type
  local dep_value
  local rel_path
  local -n npm_deps_ref="${npm_array_name}"
  local -n pip_deps_ref="${pip_array_name}"
  local -n system_deps_ref="${system_array_name}"
  local -n manifest_count_ref="${manifest_count_name}"

  npm_deps_ref=()
  pip_deps_ref=()
  system_deps_ref=()
  manifest_count_ref=0

  if [ ! -d "${plugin_root}" ]; then
    return 0
  fi

  while IFS= read -r -d '' manifest_file; do
    manifest_files+=("${manifest_file}")
  done < <(find "${plugin_root}" -type f -name plugin-manifest.json -print0 2>/dev/null)

  manifest_count_ref="${#manifest_files[@]}"
  if [ "${manifest_count_ref}" -eq 0 ]; then
    return 0
  fi

  for manifest_file in "${manifest_files[@]}"; do
    rel_path="${manifest_file#${component_dir}/}"
    parse_err=""
    if ! parsed_rows="$(emit_manifest_dependencies "${manifest_file}" 2>/dev/null)"; then
      if command -v python3 >/dev/null 2>&1 || command -v node >/dev/null 2>&1; then
        parse_err="failed to parse plugin manifest JSON"
      else
        parse_err="python3/node is not available to parse plugin-manifest dependencies"
      fi
      add_install_warning "${component_name}: ${parse_err} (${rel_path})"
      log WARN "${component_name}: ${parse_err} (${rel_path})"
      continue
    fi

    while IFS= read -r dep_row; do
      if [ -z "${dep_row}" ]; then
        continue
      fi
      IFS='|' read -r dep_type dep_value <<< "${dep_row}"
      if [ -z "${dep_type}" ] || [ -z "${dep_value}" ]; then
        continue
      fi
      case "${dep_type}" in
        npm)
          append_unique "${npm_array_name}" "${dep_value}"
          ;;
        pip)
          append_unique "${pip_array_name}" "${dep_value}"
          ;;
        system)
          append_unique "${system_array_name}" "${dep_value}"
          ;;
        *)
          continue
          ;;
      esac
      add_dependency_matrix_row "${component_name}" "plugin-manifest" "${rel_path}" "${dep_type}" "${dep_value}"
    done <<< "${parsed_rows}"
  done
}

build_command_with_args() {
  local base_cmd="$1"
  shift
  local arg
  local command_line="${base_cmd}"
  for arg in "$@"; do
    command_line+=" $(printf '%q' "${arg}")"
  done
  printf '%s\n' "${command_line}"
}

precheck_system_dependency_list() {
  local component_name="$1"
  local package_manager="$2"
  shift 2
  local dependency
  local strict_missing=0

  for dependency in "$@"; do
    if ! check_required_command "${dependency}" "plugin manifest system dependency (${component_name})" "${package_manager}"; then
      if [ "${STRICT_DEPENDENCIES}" -eq 1 ]; then
        strict_missing=1
      fi
    fi
  done

  if [ "${strict_missing}" -eq 1 ]; then
    return 1
  fi
  return 0
}

json_escape() {
  local value="$1"
  value="${value//\\/\\\\}"
  value="${value//\"/\\\"}"
  value="${value//$'\n'/\\n}"
  value="${value//$'\r'/\\r}"
  value="${value//$'\t'/\\t}"
  printf '%s' "${value}"
}

random_token() {
  local size="${1:-24}"
  local token
  token="$(cat /proc/sys/kernel/random/uuid 2>/dev/null | tr -d '-')"
  if [ -z "${token}" ]; then
    token="$(date +%s%N)"
  fi
  printf '%s\n' "${token}" | cut -c1-"${size}"
}

upsert_env_value() {
  local file_path="$1"
  local key="$2"
  local value="$3"
  local tmp_file="${file_path}.tmp.$$"

  awk -v k="${key}" -v v="${value}" '
    BEGIN { replaced = 0 }
    $0 ~ ("^" k "=") { print k "=" v; replaced = 1; next }
    { print }
    END { if (replaced == 0) print k "=" v }
  ' "${file_path}" > "${tmp_file}"

  mv "${tmp_file}" "${file_path}"
}

run_step_command() {
  local step_id="$1"
  local workdir="$2"
  local command="$3"

  log INFO "${step_id}: ${command}"
  log INFO "${step_id}: cwd=${workdir}"

  if [ "${DRY_RUN}" -eq 1 ]; then
    log INFO "${step_id}: dry-run, skipped command"
    return 0
  fi

  (
    cd "${workdir}"
    bash -lc "${command}"
  )
}

parse_install_components() {
  local normalized
  local token

  INSTALL_TOOLBOX_ENABLED=0
  INSTALL_CHAT_ENABLED=0

  normalized="$(printf '%s' "${INSTALL_COMPONENTS_ARG}" | tr ',' ' ' | tr '[:upper:]' '[:lower:]')"

  if [ -z "${normalized// /}" ] || [ "${normalized}" = "all" ]; then
    INSTALL_TOOLBOX_ENABLED=1
    INSTALL_CHAT_ENABLED=1
    return 0
  fi

  for token in ${normalized}; do
    case "${token}" in
      all)
        INSTALL_TOOLBOX_ENABLED=1
        INSTALL_CHAT_ENABLED=1
        ;;
      toolbox|vcptoolbox|backend)
        INSTALL_TOOLBOX_ENABLED=1
        ;;
      chat|vcpchat|frontend)
        INSTALL_CHAT_ENABLED=1
        ;;
      *)
        echo "Invalid --components value: ${INSTALL_COMPONENTS_ARG}" >&2
        echo "Supported values: all | toolbox | chat | toolbox,chat" >&2
        return 1
        ;;
    esac
  done

  if [ "${INSTALL_TOOLBOX_ENABLED}" -eq 0 ] && [ "${INSTALL_CHAT_ENABLED}" -eq 0 ]; then
    echo "No install component selected." >&2
    return 1
  fi

  return 0
}

setup_vcptoolbox_config() {
  local toolbox_dir="$1"
  local chat_dir="$2"
  local config_file="${toolbox_dir}/config.env"
  local config_example="${toolbox_dir}/config.env.example"
  local api_url="${VCP_API_URL_ARG:-http://127.0.0.1:3000}"
  local api_key="${VCP_API_KEY_ARG:-sk-change-me}"
  local vcp_port="${VCP_PORT_ARG:-6005}"
  local admin_user="${ADMIN_USER_ARG:-admin}"
  local admin_password="${ADMIN_PASSWORD_ARG:-$(random_token 20)}"
  local service_key
  local image_key
  local file_key
  local vcp_key
  local callback_url

  service_key="Key_$(random_token 16)"
  image_key="Images_$(random_token 12)"
  file_key="$(random_token 12)"
  vcp_key="${VCP_KEY_ARG:-$(random_token 24)}"
  callback_url="http://127.0.0.1:${vcp_port}/plugin-callback"

  if [ -f "${config_file}" ] && [ "${FORCE_CONFIG_REWRITE}" -eq 0 ]; then
    log INFO "VCPToolBox config exists, keeping current file: ${config_file}"
  else
    if [ "${DRY_RUN}" -eq 1 ]; then
      log INFO "Dry-run: would create/update ${config_file}"
    else
      if [ -f "${config_example}" ]; then
        cp "${config_example}" "${config_file}"
      else
        cat > "${config_file}" <<'EOF'
API_Key=sk-change-me
API_URL=http://127.0.0.1:3000
PORT=6005
Key=change-me
Image_Key=Images_change_me
File_Key=change_me
VCP_Key=change-me
AdminUsername=admin
AdminPassword=change-me
CALLBACK_BASE_URL=http://127.0.0.1:6005/plugin-callback
EOF
      fi
    fi
  fi

  if [ "${DRY_RUN}" -eq 0 ] && [ -f "${config_file}" ]; then
    upsert_env_value "${config_file}" "API_URL" "${api_url}"
    upsert_env_value "${config_file}" "API_Key" "${api_key}"
    upsert_env_value "${config_file}" "PORT" "${vcp_port}"
    upsert_env_value "${config_file}" "Key" "${service_key}"
    upsert_env_value "${config_file}" "Image_Key" "${image_key}"
    upsert_env_value "${config_file}" "File_Key" "${file_key}"
    upsert_env_value "${config_file}" "VCP_Key" "${vcp_key}"
    upsert_env_value "${config_file}" "AdminUsername" "${admin_user}"
    upsert_env_value "${config_file}" "AdminPassword" "${admin_password}"
    upsert_env_value "${config_file}" "CALLBACK_BASE_URL" "${callback_url}"
    upsert_env_value "${config_file}" "VarVchatPath" "${chat_dir}"
    chmod 600 "${config_file}" || true
  fi

  if [ "${DRY_RUN}" -eq 0 ]; then
    mkdir -p \
      "${toolbox_dir}/VCPTimedContacts" \
      "${toolbox_dir}/dailynote" \
      "${toolbox_dir}/image" \
      "${toolbox_dir}/file" \
      "${toolbox_dir}/TVStxt" \
      "${toolbox_dir}/VCPAsyncResults" \
      "${toolbox_dir}/Plugin/VCPLog/log" \
      "${toolbox_dir}/Plugin/EmojiListGenerator/generated_lists" \
      "${toolbox_dir}/VectorStore"
  else
    log INFO "Dry-run: would create VCPToolBox runtime directories"
  fi
}

setup_vcpchat_config() {
  local chat_dir="$1"
  local toolbox_dir="$2"
  local api_port="${VCP_PORT_ARG:-6005}"
  local settings_dir="${chat_dir}/AppData"
  local settings_file="${settings_dir}/settings.json"
  local server_url="${CHAT_SERVER_URL_ARG:-http://127.0.0.1:${api_port}/v1/chat/completions}"
  local api_key="${CHAT_API_KEY_ARG:-${VCP_API_KEY_ARG:-sk-change-me}}"
  local log_url="${CHAT_LOG_URL_ARG:-http://127.0.0.1:${api_port}}"
  local log_key="${CHAT_LOG_KEY_ARG:-${VCP_KEY_ARG:-$(random_token 20)}}"

  if [ "${DRY_RUN}" -eq 0 ]; then
    mkdir -p \
      "${settings_dir}" \
      "${settings_dir}/Agents" \
      "${settings_dir}/UserData" \
      "${settings_dir}/UserData/attachments" \
      "${settings_dir}/Notemodules" \
      "${settings_dir}/file" \
      "${settings_dir}/canvas"
  else
    log INFO "Dry-run: would create VCPChat AppData directories under ${settings_dir}"
  fi

  if [ -f "${settings_file}" ] && [ "${FORCE_CONFIG_REWRITE}" -eq 0 ]; then
    log INFO "VCPChat settings exists, keeping current file: ${settings_file}"
    return
  fi

  if [ "${DRY_RUN}" -eq 1 ]; then
    log INFO "Dry-run: would generate ${settings_file}"
    return
  fi

  cat > "${settings_file}" <<EOF
{
  "sidebarWidth": 260,
  "notificationsSidebarWidth": 300,
  "userName": "用户",
  "vcpServerUrl": "$(json_escape "${server_url}")",
  "vcpApiKey": "$(json_escape "${api_key}")",
  "vcpLogUrl": "$(json_escape "${log_url}")",
  "vcpLogKey": "$(json_escape "${log_key}")",
  "networkNotesPaths": [],
  "enableAgentBubbleTheme": false,
  "enableSmoothStreaming": false,
  "minChunkBufferSize": 1,
  "smoothStreamIntervalMs": 25,
  "assistantAgent": "",
  "enableDistributedServer": true,
  "agentMusicControl": false,
  "enableDistributedServerLogs": false,
  "enableVcpToolInjection": false,
  "lastOpenItemId": null,
  "lastOpenItemType": null,
  "lastOpenTopicId": null,
  "combinedItemOrder": [],
  "agentOrder": [],
  "vcpToolBoxPath": "$(json_escape "${toolbox_dir}")"
}
EOF
}

detect_package_manager() {
  if command -v apt-get >/dev/null 2>&1; then
    printf '%s\n' "apt"
    return
  fi
  if command -v dnf >/dev/null 2>&1; then
    printf '%s\n' "dnf"
    return
  fi
  if command -v yum >/dev/null 2>&1; then
    printf '%s\n' "yum"
    return
  fi
  if command -v pacman >/dev/null 2>&1; then
    printf '%s\n' "pacman"
    return
  fi
  if command -v zypper >/dev/null 2>&1; then
    printf '%s\n' "zypper"
    return
  fi
  printf '%s\n' "unknown"
}

build_install_hint() {
  local command_name="$1"
  local manager="$2"
  case "${manager}" in
    apt)
      printf '%s\n' "sudo apt-get update && sudo apt-get install -y ${command_name}"
      ;;
    dnf)
      printf '%s\n' "sudo dnf install -y ${command_name}"
      ;;
    yum)
      printf '%s\n' "sudo yum install -y ${command_name}"
      ;;
    pacman)
      printf '%s\n' "sudo pacman -Sy --noconfirm ${command_name}"
      ;;
    zypper)
      printf '%s\n' "sudo zypper install -y ${command_name}"
      ;;
    *)
      printf '%s\n' "<package-manager> install ${command_name}"
      ;;
  esac
}

check_required_command() {
  local command_name="$1"
  local reason="$2"
  local package_manager="$3"

  if command -v "${command_name}" >/dev/null 2>&1; then
    local line
    line="$("${command_name}" --version 2>/dev/null | head -n 1 || true)"
    if [ -n "${line}" ]; then
      log INFO "Dependency ${command_name} detected: ${line}"
    else
      log INFO "Dependency ${command_name} detected"
    fi
    return 0
  fi

  local hint
  local message
  hint="$(build_install_hint "${command_name}" "${package_manager}")"
  message="Missing command '${command_name}' (${reason}). Suggestion: ${hint}"

  if [ "${STRICT_DEPENDENCIES}" -eq 1 ]; then
    add_install_error "${message}"
    log ERROR "${message}"
  else
    add_install_warning "${message}"
    log WARN "${message}"
  fi

  return 1
}

install_plugin_python_requirements() {
  local component_name="$1"
  local component_dir="$2"
  local plugin_root="${component_dir}/Plugin"
  local req_file
  local req_files=()
  local req_dir
  local rel_path

  if [ ! -d "${plugin_root}" ]; then
    log INFO "${component_name}: no Plugin directory detected, skip plugin python dependencies"
    return 0
  fi

  while IFS= read -r -d '' req_file; do
    req_files+=("${req_file}")
  done < <(find "${plugin_root}" -type f -name requirements.txt -print0 2>/dev/null)

  if [ "${#req_files[@]}" -eq 0 ]; then
    log INFO "${component_name}: no plugin requirements.txt files found"
    return 0
  fi

  log INFO "${component_name}: found ${#req_files[@]} plugin requirements file(s)"

  if [ "${SKIP_PYTHON_INSTALL}" -eq 1 ]; then
    add_install_warning "${component_name}: plugin python requirements skipped because --skip-python-install is enabled"
    return 0
  fi

  for req_file in "${req_files[@]}"; do
    req_dir="$(dirname "${req_file}")"
    rel_path="${req_file#${component_dir}/}"
    if [ "${DRY_RUN}" -eq 1 ]; then
      log INFO "Dry-run: would install plugin python requirements from ${rel_path}"
      continue
    fi

    if command -v pip3 >/dev/null 2>&1; then
      run_step_command "S42_${component_name}_PLUGIN_PY" "${req_dir}" "pip3 install -r requirements.txt"
    elif command -v python3 >/dev/null 2>&1; then
      run_step_command "S42_${component_name}_PLUGIN_PY" "${req_dir}" "python3 -m pip install -r requirements.txt"
    else
      add_install_error "${component_name}: cannot install plugin python requirements because pip3/python3 is missing (${rel_path})"
      return 1
    fi
  done

  return 0
}

install_plugin_manifest_dependencies() {
  local component_name="$1"
  local component_dir="$2"
  local package_manager="$3"
  local plugin_root="${component_dir}/Plugin"
  local req_file
  local req_files=()
  local req_count=0
  local rel_req_path
  local manifest_npm_deps=()
  local manifest_pip_deps=()
  local manifest_system_deps=()
  local manifest_count=0
  local npm_command
  local pip_command

  if [ -d "${plugin_root}" ]; then
    while IFS= read -r -d '' req_file; do
      req_files+=("${req_file}")
    done < <(find "${plugin_root}" -type f -name requirements.txt -print0 2>/dev/null)
  fi
  req_count="${#req_files[@]}"
  for req_file in "${req_files[@]}"; do
    rel_req_path="${req_file#${component_dir}/}"
    add_dependency_matrix_row "${component_name}" "plugin-requirements" "${rel_req_path}" "pip-file" "requirements.txt"
  done

  collect_plugin_manifest_dependencies \
    "${component_name}" \
    "${component_dir}" \
    manifest_npm_deps \
    manifest_pip_deps \
    manifest_system_deps \
    manifest_count

  if [ "${manifest_count}" -eq 0 ] && [ "${req_count}" -eq 0 ]; then
    add_install_step "S43_${component_name}_PLUGIN_MATRIX" "success" "no plugin-manifest.json or plugin requirements found"
    return 0
  fi

  if [ "${#manifest_system_deps[@]}" -gt 0 ]; then
    if ! precheck_system_dependency_list "${component_name}" "${package_manager}" "${manifest_system_deps[@]}"; then
      add_install_step "S43_${component_name}_PLUGIN_MATRIX" "failed" "strict system dependency check failed"
      return 1
    fi
  fi

  add_install_step \
    "S43_${component_name}_PLUGIN_MATRIX" \
    "success" \
    "manifests=${manifest_count},plugin_requirements=${req_count},npm=${#manifest_npm_deps[@]},pip=${#manifest_pip_deps[@]},system=${#manifest_system_deps[@]},apply=${INSTALL_PLUGIN_MANIFEST_DEPS}"

  if [ "${INSTALL_PLUGIN_MANIFEST_DEPS}" -eq 0 ]; then
    return 0
  fi

  if [ "${#manifest_npm_deps[@]}" -gt 0 ]; then
    if [ "${SKIP_NODE_INSTALL}" -eq 1 ]; then
      add_install_warning "${component_name}: manifest npm dependencies skipped by --skip-node-install"
    elif [ ! -f "${component_dir}/package.json" ]; then
      add_install_warning "${component_name}: manifest npm dependencies detected but package.json is missing"
    else
      npm_command="$(build_command_with_args "npm install --no-audit --no-fund --no-save" "${manifest_npm_deps[@]}")"
      run_step_command "S44_${component_name}_PLUGIN_MANIFEST_NPM" "${component_dir}" "${npm_command}"
    fi
  fi

  if [ "${#manifest_pip_deps[@]}" -gt 0 ]; then
    if [ "${SKIP_PYTHON_INSTALL}" -eq 1 ]; then
      add_install_warning "${component_name}: manifest pip dependencies skipped by --skip-python-install"
    elif command -v pip3 >/dev/null 2>&1; then
      pip_command="$(build_command_with_args "pip3 install" "${manifest_pip_deps[@]}")"
      run_step_command "S45_${component_name}_PLUGIN_MANIFEST_PY" "${component_dir}" "${pip_command}"
    elif command -v python3 >/dev/null 2>&1; then
      pip_command="$(build_command_with_args "python3 -m pip install" "${manifest_pip_deps[@]}")"
      run_step_command "S45_${component_name}_PLUGIN_MANIFEST_PY" "${component_dir}" "${pip_command}"
    else
      add_install_error "${component_name}: cannot install manifest pip dependencies because pip3/python3 is missing"
      return 1
    fi
  fi

  return 0
}

install_component_dependencies() {
  local component_name="$1"
  local component_dir="$2"
  local package_manager="$3"

  if [ -f "${component_dir}/package.json" ]; then
    add_dependency_matrix_row "${component_name}" "component" "package.json" "npm-file" "package.json"
  fi

  if [ -f "${component_dir}/requirements.txt" ]; then
    add_dependency_matrix_row "${component_name}" "component" "requirements.txt" "pip-file" "requirements.txt"
  fi

  if [ "${SKIP_NODE_INSTALL}" -eq 0 ] && [ -f "${component_dir}/package.json" ]; then
    run_step_command "S40_${component_name}_NODE" "${component_dir}" "npm install --no-audit --no-fund"
  else
    add_install_warning "${component_name}: node install skipped"
    log WARN "${component_name}: node install skipped"
  fi

  if [ "${SKIP_PYTHON_INSTALL}" -eq 0 ] && [ -f "${component_dir}/requirements.txt" ]; then
    if command -v pip3 >/dev/null 2>&1; then
      run_step_command "S41_${component_name}_PY" "${component_dir}" "pip3 install -r requirements.txt"
    elif command -v python3 >/dev/null 2>&1; then
      run_step_command "S41_${component_name}_PY" "${component_dir}" "python3 -m pip install -r requirements.txt"
    else
      add_install_warning "${component_name}: python dependency install skipped (pip/python3 not found)"
      log WARN "${component_name}: python dependency install skipped (pip/python3 not found)"
    fi
  elif [ "${SKIP_PYTHON_INSTALL}" -eq 1 ]; then
    add_install_warning "${component_name}: python install skipped by flag"
    log WARN "${component_name}: python install skipped by flag"
  fi

  install_plugin_manifest_dependencies "${component_name}" "${component_dir}" "${package_manager}"
}

write_install_report() {
  local workspace_root="$1"
  local toolbox_dir="$2"
  local chat_dir="$3"
  local now_iso
  local idx
  local step_row
  local step_id
  local step_status
  local step_detail

  now_iso="$(timestamp)"
  REPORT_DIR="${INSTALLER_HOME}/reports"
  INSTALL_REPORT_JSON="${REPORT_DIR}/install-report-${SESSION_ID}.json"
  INSTALL_REPORT_MD="${REPORT_DIR}/install-report-${SESSION_ID}.md"
  DEPENDENCY_MATRIX_REPORT_MD="${REPORT_DIR}/dependency-matrix-${SESSION_ID}.md"

  if [ "${DRY_RUN}" -eq 1 ]; then
    log INFO "Dry-run: would write install reports to ${REPORT_DIR}"
    return
  fi

  mkdir -p "${REPORT_DIR}"

  {
    printf '{\n'
    printf '  "session_id": "%s",\n' "$(json_escape "${SESSION_ID}")"
    printf '  "generated_at": "%s",\n' "$(json_escape "${now_iso}")"
    printf '  "status": "%s",\n' "$(json_escape "${INSTALL_STATUS}")"
    printf '  "workspace_root": "%s",\n' "$(json_escape "${workspace_root}")"
    printf '  "toolbox_dir": "%s",\n' "$(json_escape "${toolbox_dir}")"
    printf '  "chat_dir": "%s",\n' "$(json_escape "${chat_dir}")"
    printf '  "runtime": {\n'
    printf '    "mode": "%s",\n' "$(json_escape "${RUNTIME_MODE}")"
    printf '    "manifest_source": "%s",\n' "$(json_escape "${RUNTIME_MANIFEST_SOURCE}")"
    printf '    "manifest_path": "%s",\n' "$(json_escape "${RUNTIME_MANIFEST_PATH_RESOLVED}")"
    printf '    "wrapper_path": "%s"\n' "$(json_escape "${RUNTIME_WRAPPER_PATH}")"
    printf '  },\n'
    printf '  "dependency_matrix_report": "%s",\n' "$(json_escape "${DEPENDENCY_MATRIX_REPORT_MD}")"
    printf '  "global_mutation": {\n'
    printf '    "path_modified": false,\n'
    printf '    "global_npm_install": false,\n'
    printf '    "global_pip_install": false,\n'
    printf '    "safe_default": true\n'
    printf '  },\n'
    printf '  "warnings": [\n'
    for idx in "${!INSTALL_WARNINGS[@]}"; do
      printf '    "%s"' "$(json_escape "${INSTALL_WARNINGS[$idx]}")"
      if [ "${idx}" -lt "$((${#INSTALL_WARNINGS[@]} - 1))" ]; then
        printf ','
      fi
      printf '\n'
    done
    printf '  ],\n'
    printf '  "errors": [\n'
    for idx in "${!INSTALL_ERRORS[@]}"; do
      printf '    "%s"' "$(json_escape "${INSTALL_ERRORS[$idx]}")"
      if [ "${idx}" -lt "$((${#INSTALL_ERRORS[@]} - 1))" ]; then
        printf ','
      fi
      printf '\n'
    done
    printf '  ],\n'
    printf '  "steps": [\n'
    for idx in "${!INSTALL_STEPS[@]}"; do
      step_row="${INSTALL_STEPS[$idx]}"
      step_id="${step_row%%|*}"
      step_row="${step_row#*|}"
      step_status="${step_row%%|*}"
      step_detail="${step_row#*|}"
      printf '    {"step_id":"%s","status":"%s","detail":"%s"}' \
        "$(json_escape "${step_id}")" \
        "$(json_escape "${step_status}")" \
        "$(json_escape "${step_detail}")"
      if [ "${idx}" -lt "$((${#INSTALL_STEPS[@]} - 1))" ]; then
        printf ','
      fi
      printf '\n'
    done
    printf '  ]\n'
    printf '}\n'
  } > "${INSTALL_REPORT_JSON}"

  {
    printf '# Install Report\n\n'
    printf -- '- Session: `%s`\n' "${SESSION_ID}"
    printf -- '- Generated At (UTC): `%s`\n' "${now_iso}"
    printf -- '- Status: `%s`\n' "${INSTALL_STATUS}"
    printf -- '- Workspace: `%s`\n' "${workspace_root}"
    printf -- '- VCPToolBox: `%s`\n' "${toolbox_dir}"
    printf -- '- VCPChat: `%s`\n' "${chat_dir}"
    printf -- '- Runtime Mode: `%s`\n' "${RUNTIME_MODE}"
    printf -- '- Runtime Manifest: `%s`\n' "${RUNTIME_MANIFEST_SOURCE:-<unset>}"
    printf -- '- Runtime Wrapper: `%s`\n' "${RUNTIME_WRAPPER_PATH:-<unset>}"
    printf -- '- Dependency Matrix Report: `%s`\n' "${DEPENDENCY_MATRIX_REPORT_MD}"
    printf -- '- Global Mutation Safe: `true`\n'
    printf '\n## Steps\n\n'
    for step_row in "${INSTALL_STEPS[@]}"; do
      step_id="${step_row%%|*}"
      step_row="${step_row#*|}"
      step_status="${step_row%%|*}"
      step_detail="${step_row#*|}"
      printf -- '- `%s` `%s` %s\n' "${step_id}" "${step_status}" "${step_detail}"
    done
    printf '\n## Warnings\n\n'
    if [ "${#INSTALL_WARNINGS[@]}" -eq 0 ]; then
      printf -- '- none\n'
    else
      for step_row in "${INSTALL_WARNINGS[@]}"; do
        printf -- '- %s\n' "${step_row}"
      done
    fi
    printf '\n## Errors\n\n'
    if [ "${#INSTALL_ERRORS[@]}" -eq 0 ]; then
      printf -- '- none\n'
    else
      for step_row in "${INSTALL_ERRORS[@]}"; do
        printf -- '- %s\n' "${step_row}"
      done
    fi
  } > "${INSTALL_REPORT_MD}"

  write_dependency_matrix_report

  log INFO "Install report JSON: ${INSTALL_REPORT_JSON}"
  log INFO "Install report Markdown: ${INSTALL_REPORT_MD}"
}

save_launcher_config() {
  local workspace_root="$1"
  local backend_cwd="$2"
  local backend_cmd="$3"
  local chat_cwd="$4"
  local chat_cmd="$5"
  local startup_delay="$6"
  local runtime_mode_cfg="${7:-system}"
  local runtime_wrapper_cfg="${8:-}"
  local runtime_manifest_cfg="${9:-}"

  if [ "${DRY_RUN}" -eq 1 ]; then
    log INFO "Dry-run: skip writing launcher config (${CONFIG_FILE})"
    return
  fi

  {
    printf '# Generated by vcp-installer at %s\n' "$(timestamp)"
    printf 'CONFIG_VERSION=%q\n' "2"
    printf 'INITIALIZED_AT=%q\n' "$(timestamp)"
    printf 'WORKSPACE_ROOT=%q\n' "${workspace_root}"
    printf 'BACKEND_CWD=%q\n' "${backend_cwd}"
    printf 'BACKEND_CMD=%q\n' "${backend_cmd}"
    printf 'CHAT_CWD=%q\n' "${chat_cwd}"
    printf 'CHAT_CMD=%q\n' "${chat_cmd}"
    printf 'STARTUP_DELAY_CFG=%q\n' "${startup_delay}"
    printf 'RUNTIME_MODE_CFG=%q\n' "${runtime_mode_cfg}"
    printf 'RUNTIME_WRAPPER_CFG=%q\n' "${runtime_wrapper_cfg}"
    printf 'RUNTIME_MANIFEST_CFG=%q\n' "${runtime_manifest_cfg}"
  } > "${CONFIG_FILE}"

  chmod 600 "${CONFIG_FILE}"
}

load_launcher_config() {
  if [ ! -f "${CONFIG_FILE}" ]; then
    return 1
  fi

  # shellcheck disable=SC1090
  source "${CONFIG_FILE}"

  if [ -z "${BACKEND_CWD:-}" ] || [ -z "${BACKEND_CMD:-}" ] || [ -z "${CHAT_CWD:-}" ] || [ -z "${CHAT_CMD:-}" ]; then
    log ERROR "Launcher config is incomplete: ${CONFIG_FILE}"
    return 2
  fi

  if [ -z "${RUNTIME_MODE_CFG:-}" ]; then
    RUNTIME_MODE_CFG="system"
  fi
  if [ -z "${RUNTIME_WRAPPER_CFG:-}" ]; then
    RUNTIME_WRAPPER_CFG=""
  fi
  if [ -z "${RUNTIME_MANIFEST_CFG:-}" ]; then
    RUNTIME_MANIFEST_CFG=""
  fi

  return 0
}

prompt_cli_value() {
  local prompt="$1"
  local default_value="$2"
  local input=""

  read -r -p "${prompt} [${default_value}]: " input || true
  if [ -z "${input}" ]; then
    printf '%s\n' "${default_value}"
  else
    printf '%s\n' "${input}"
  fi
}

collect_init_values() {
  local default_workspace
  local default_backend_cwd
  local default_backend_cmd
  local default_chat_cwd
  local default_chat_cmd

  default_workspace="$(detect_workspace_root)"
  default_backend_cwd="${default_workspace}/VCPToolBox"
  default_backend_cmd="node server.js"
  default_chat_cwd="${default_workspace}/VCPChat"
  default_chat_cmd="npm run start"

  WORKSPACE_ROOT_VAL="${WORKSPACE_ROOT_ARG:-${default_workspace}}"
  BACKEND_CWD_VAL="${BACKEND_CWD_ARG:-${default_backend_cwd}}"
  BACKEND_CMD_VAL="${BACKEND_CMD_ARG:-${default_backend_cmd}}"
  CHAT_CWD_VAL="${CHAT_CWD_ARG:-${default_chat_cwd}}"
  CHAT_CMD_VAL="${CHAT_CMD_ARG:-${default_chat_cmd}}"

  if [ "${HEADLESS}" -eq 1 ] && [ "${AUTO_APPROVE}" -eq 0 ]; then
    emit_init_required_block
    exit 31
  fi

  if [ "${AUTO_APPROVE}" -eq 1 ]; then
    return
  fi

  if [ "${MODE}" = "gui" ] && [ -n "${DISPLAY:-}" ] && command -v zenity >/dev/null 2>&1; then
    local sep=$'\x1f'
    local form_output

    form_output="$(zenity --forms \
      --title="VCP Installer Initialization" \
      --text="Set startup profile for backend and VCPChat." \
      --separator="${sep}" \
      --add-entry="Workspace Root" \
      --add-entry="Backend Working Directory" \
      --add-entry="Backend Start Command" \
      --add-entry="VCPChat Working Directory" \
      --add-entry="VCPChat Start Command" \
      --add-entry="Startup Delay Seconds")"

    if [ -z "${form_output}" ]; then
      log WARN "Initialization wizard cancelled."
      exit 4
    fi

    IFS="${sep}" read -r WORKSPACE_ROOT_VAL BACKEND_CWD_VAL BACKEND_CMD_VAL CHAT_CWD_VAL CHAT_CMD_VAL STARTUP_DELAY_FORM <<< "${form_output}"
    if [ -n "${STARTUP_DELAY_FORM:-}" ]; then
      STARTUP_DELAY="${STARTUP_DELAY_FORM}"
    fi
  else
    WORKSPACE_ROOT_VAL="$(prompt_cli_value "Workspace root" "${WORKSPACE_ROOT_VAL}")"
    BACKEND_CWD_VAL="$(prompt_cli_value "Backend working directory" "${BACKEND_CWD_VAL}")"
    BACKEND_CMD_VAL="$(prompt_cli_value "Backend start command" "${BACKEND_CMD_VAL}")"
    CHAT_CWD_VAL="$(prompt_cli_value "VCPChat working directory" "${CHAT_CWD_VAL}")"
    CHAT_CMD_VAL="$(prompt_cli_value "VCPChat start command" "${CHAT_CMD_VAL}")"
    STARTUP_DELAY="$(prompt_cli_value "Startup delay seconds" "${STARTUP_DELAY}")"
  fi
}

validate_startup_delay() {
  if ! printf '%s' "${STARTUP_DELAY}" | grep -Eq '^[0-9]+$'; then
    echo "Invalid --startup-delay: ${STARTUP_DELAY}" >&2
    exit 2
  fi
}

validate_vcp_port() {
  if [ -z "${VCP_PORT_ARG}" ]; then
    return
  fi

  if ! printf '%s' "${VCP_PORT_ARG}" | grep -Eq '^[0-9]+$'; then
    echo "Invalid --vcp-port: ${VCP_PORT_ARG}" >&2
    exit 2
  fi
}

start_component() {
  local name="$1"
  local cwd="$2"
  local cmd="$3"
  local pid_file="${RUN_DIR}/${name}.pid"
  local log_file="${LOG_DIR}/${name}.log"

  if [ -f "${pid_file}" ]; then
    local existing_pid
    existing_pid="$(cat "${pid_file}" 2>/dev/null || true)"
    if safe_pid_running "${existing_pid}"; then
      log INFO "${name} already running (pid=${existing_pid})."
      return 0
    fi
    rm -f "${pid_file}"
  fi

  if [ ! -d "${cwd}" ]; then
    log ERROR "${name} working directory not found: ${cwd}"
    return 21
  fi

  if [ "${DRY_RUN}" -eq 1 ]; then
    log INFO "Dry-run: would start ${name}"
    log INFO "  cwd=${cwd}"
    log INFO "  cmd=${cmd}"
    return 0
  fi

  (
    cd "${cwd}"
    nohup bash -lc "${cmd}" >> "${log_file}" 2>&1 &
    echo $! > "${pid_file}"
  )

  local new_pid
  new_pid="$(cat "${pid_file}")"
  log INFO "${name} started (pid=${new_pid})"
  log INFO "${name} log file: ${log_file}"
}

stop_component() {
  local name="$1"
  local pid_file="${RUN_DIR}/${name}.pid"

  if [ ! -f "${pid_file}" ]; then
    log INFO "${name} is not running (no pid file)."
    return 0
  fi

  local pid
  pid="$(cat "${pid_file}" 2>/dev/null || true)"

  if ! safe_pid_running "${pid}"; then
    rm -f "${pid_file}"
    log INFO "${name} pid was stale; cleaned pid file."
    return 0
  fi

  if [ "${DRY_RUN}" -eq 1 ]; then
    log INFO "Dry-run: would stop ${name} (pid=${pid})"
    return 0
  fi

  kill "${pid}" 2>/dev/null || true

  local i
  for i in 1 2 3 4 5 6 7 8 9 10; do
    if safe_pid_running "${pid}"; then
      sleep 0.3
    else
      break
    fi
  done

  if safe_pid_running "${pid}"; then
    kill -9 "${pid}" 2>/dev/null || true
  fi

  rm -f "${pid_file}"
  log INFO "${name} stopped"
}

show_component_status() {
  local name="$1"
  local pid_file="${RUN_DIR}/${name}.pid"

  if [ ! -f "${pid_file}" ]; then
    printf '%s: STOPPED\n' "${name}"
    return
  fi

  local pid
  pid="$(cat "${pid_file}" 2>/dev/null || true)"
  if safe_pid_running "${pid}"; then
    printf '%s: RUNNING (pid=%s)\n' "${name}" "${pid}"
  else
    printf '%s: STOPPED (stale pid file)\n' "${name}"
  fi
}

run_install_flow() {
  local session_file="$1"
  local workspace_root
  local toolbox_dir
  local chat_dir
  local backend_cmd
  local chat_cmd
  local package_manager
  local precheck_status

  INSTALL_STATUS="success"
  INSTALL_WARNINGS=()
  INSTALL_ERRORS=()
  INSTALL_STEPS=()
  DEPENDENCY_MATRIX_ROWS=()

  write_state "${session_file}" "S00_PRECHECK" "running" "precheck-started"
  log INFO "Step S00_PRECHECK: validating runtime dependencies"
  package_manager="$(detect_package_manager)"
  check_required_command "git" "source checkout and update operations" "${package_manager}" || true
  if [ "${SKIP_NODE_INSTALL}" -eq 0 ] || [ "${START_AFTER_INSTALL}" -eq 1 ]; then
    check_required_command "node" "component runtime and build scripts" "${package_manager}" || true
  fi
  if [ "${SKIP_NODE_INSTALL}" -eq 0 ]; then
    check_required_command "npm" "node dependency installation" "${package_manager}" || true
  fi
  if [ "${SKIP_PYTHON_INSTALL}" -eq 0 ] || [ "${INSTALL_PLUGIN_PYTHON_DEPS}" -eq 1 ]; then
    check_required_command "python3" "python dependencies and helper scripts" "${package_manager}" || true
  fi
  if [ "${SKIP_PYTHON_INSTALL}" -eq 0 ]; then
    if ! command -v pip3 >/dev/null 2>&1 && ! command -v python3 >/dev/null 2>&1; then
      check_required_command "pip3" "python dependency installation" "${package_manager}" || true
    fi
  fi
  if [ "${INSTALL_STATUS}" = "failed" ]; then
    precheck_status="failed"
  elif [ "${INSTALL_STATUS}" = "warning" ]; then
    precheck_status="warning"
  else
    precheck_status="success"
  fi
  add_install_step "S00_PRECHECK" "${precheck_status}" "runtime dependency check finished (pkg-manager=${package_manager})"

  if ! parse_install_components; then
    write_state "${session_file}" "S05_COMPONENTS" "failed" "invalid-component-selection"
    exit 2
  fi

  write_state "${session_file}" "S05_COMPONENTS" "running" "component-selection"
  add_install_step \
    "S05_COMPONENTS" \
    "success" \
    "toolbox=${INSTALL_TOOLBOX_ENABLED},chat=${INSTALL_CHAT_ENABLED}"

  workspace_root="$(detect_workspace_root)"
  toolbox_dir="${workspace_root}/VCPToolBox"
  chat_dir="${workspace_root}/VCPChat"

  write_state "${session_file}" "S10_WORKSPACE" "running" "workspace-detection"
  log INFO "Step S10_WORKSPACE: workspace root ${workspace_root}"
  add_install_step "S10_WORKSPACE" "success" "workspace=${workspace_root}"

  if [ "${SIMULATE_GUI_STEP}" -eq 1 ]; then
    write_state "${session_file}" "S45_GUI_REQUIRED" "blocked" "gui-required-step"
    add_install_step "S45_GUI_REQUIRED" "blocked" "simulated gui-required step"
    if [ "${HEADLESS}" -eq 1 ]; then
      emit_gui_required_block
      exit 30
    fi

    if [ "${MODE}" = "gui" ] && [ -n "${DISPLAY:-}" ] && command -v zenity >/dev/null 2>&1; then
      zenity --info --title "VCP Installer" --text "GUI required step simulated. Click OK to continue." || true
    else
      log WARN "GUI required step simulated without zenity; continuing in non-interactive fallback."
    fi
  fi

  if [ "${INSTALL_TOOLBOX_ENABLED}" -eq 1 ]; then
    write_state "${session_file}" "S50_TOOLBOX" "running" "installing-vcptoolbox"
    if [ ! -d "${toolbox_dir}" ]; then
      if [ "${DRY_RUN}" -eq 1 ]; then
        add_install_warning "VCPToolBox directory not found (dry-run): ${toolbox_dir}"
        add_install_step "S50_TOOLBOX" "warning" "missing directory in dry-run"
      else
        add_install_error "VCPToolBox directory not found: ${toolbox_dir}"
        add_install_step "S50_TOOLBOX" "failed" "missing directory"
      fi
    else
      if install_component_dependencies "TOOLBOX" "${toolbox_dir}" "${package_manager}"; then
        if [ "${INSTALL_PLUGIN_PYTHON_DEPS}" -eq 1 ]; then
          install_plugin_python_requirements "TOOLBOX" "${toolbox_dir}" || true
        fi
        setup_vcptoolbox_config "${toolbox_dir}" "${chat_dir}"
        if [ "${DRY_RUN}" -eq 1 ] || [ -f "${toolbox_dir}/config.env" ]; then
          add_install_step "S50_TOOLBOX" "success" "dependency/config completed"
        else
          add_install_error "VCPToolBox config generation failed: ${toolbox_dir}/config.env"
          add_install_step "S50_TOOLBOX" "failed" "config file missing"
        fi
      else
        add_install_error "VCPToolBox dependency installation failed"
        add_install_step "S50_TOOLBOX" "failed" "dependency install failed"
      fi
    fi
  fi

  if [ "${INSTALL_CHAT_ENABLED}" -eq 1 ]; then
    write_state "${session_file}" "S51_CHAT" "running" "installing-vcpchat"
    if [ ! -d "${chat_dir}" ]; then
      if [ "${DRY_RUN}" -eq 1 ]; then
        add_install_warning "VCPChat directory not found (dry-run): ${chat_dir}"
        add_install_step "S51_CHAT" "warning" "missing directory in dry-run"
      else
        add_install_error "VCPChat directory not found: ${chat_dir}"
        add_install_step "S51_CHAT" "failed" "missing directory"
      fi
    else
      if install_component_dependencies "CHAT" "${chat_dir}" "${package_manager}"; then
        if [ "${INSTALL_PLUGIN_PYTHON_DEPS}" -eq 1 ]; then
          install_plugin_python_requirements "CHAT" "${chat_dir}" || true
        fi
        setup_vcpchat_config "${chat_dir}" "${toolbox_dir}"
        if [ "${DRY_RUN}" -eq 1 ] || [ -f "${chat_dir}/AppData/settings.json" ]; then
          add_install_step "S51_CHAT" "success" "dependency/config completed"
        else
          add_install_error "VCPChat settings generation failed: ${chat_dir}/AppData/settings.json"
          add_install_step "S51_CHAT" "failed" "settings file missing"
        fi
      else
        add_install_error "VCPChat dependency installation failed"
        add_install_step "S51_CHAT" "failed" "dependency install failed"
      fi
    fi
  fi

  write_state "${session_file}" "S70_REPORT" "running" "report-generation"
  write_install_report "${workspace_root}" "${toolbox_dir}" "${chat_dir}"

  if [ "${START_AFTER_INSTALL}" -eq 1 ] && [ "${INSTALL_STATUS}" != "failed" ]; then
    backend_cmd="${BACKEND_CMD_ARG:-node server.js}"
    chat_cmd="${CHAT_CMD_ARG:-npm run start}"
    save_launcher_config \
      "${workspace_root}" \
      "${toolbox_dir}" \
      "${backend_cmd}" \
      "${chat_dir}" \
      "${chat_cmd}" \
      "${STARTUP_DELAY}" \
      "system" \
      "" \
      ""
    if [ "${DRY_RUN}" -eq 1 ]; then
      add_install_step "S80_START_STACK" "warning" "dry-run skipped stack startup"
    else
      run_start_stack
      add_install_step "S80_START_STACK" "success" "stack startup executed"
    fi
  fi

  if [ "${INSTALL_STATUS}" = "failed" ]; then
    write_state "${session_file}" "S90_DONE" "failed" "install-failed"
    log ERROR "Install flow completed with errors."
    exit 24
  fi

  if [ "${INSTALL_STATUS}" = "warning" ]; then
    write_state "${session_file}" "S90_DONE" "warning" "install-completed-with-warnings"
    log WARN "Install flow completed with warnings."
  else
    write_state "${session_file}" "S90_DONE" "success" "install-completed"
    log INFO "Install flow completed successfully."
  fi
}

run_init() {
  write_state "${SESSION_FILE}" "S20_INITIALIZE" "running" "collect-launch-profile"
  if [ "${INIT_RESUME_MODE}" -eq 1 ]; then
    log INFO "Resume mode: loading init values from snapshot."
  else
    collect_init_values
  fi
  validate_startup_delay

  if [ -z "${BACKEND_CMD_VAL}" ] || [ -z "${CHAT_CMD_VAL}" ]; then
    log ERROR "Initialization failed: backend/chat command cannot be empty"
    write_state "${SESSION_FILE}" "S20_INITIALIZE" "failed" "empty-command"
    exit 22
  fi

  if ! confirm_system_integration_mode; then
    write_state "${SESSION_FILE}" "S20_INITIALIZE" "failed" "system-mode-not-confirmed"
    exit 26
  fi

  save_init_profile_snapshot

  if ! run_runtime_bootstrap; then
    log ERROR "Initialization failed during runtime bootstrap."
    exit 25
  fi

  if [ "${RUNTIME_MODE}" != "portable" ]; then
    RUNTIME_WRAPPER_PATH=""
  fi

  save_launcher_config \
    "${WORKSPACE_ROOT_VAL}" \
    "${BACKEND_CWD_VAL}" \
    "${BACKEND_CMD_VAL}" \
    "${CHAT_CWD_VAL}" \
    "${CHAT_CMD_VAL}" \
    "${STARTUP_DELAY}" \
    "${RUNTIME_MODE}" \
    "${RUNTIME_WRAPPER_PATH}" \
    "${RUNTIME_MANIFEST_SOURCE}"

  log INFO "Initialization completed. Config: ${CONFIG_FILE}"
  write_state "${SESSION_FILE}" "S20_INITIALIZE" "success" "config-saved"
}

run_start_stack() {
  local delay_to_use
  local runtime_mode_to_use
  local runtime_wrapper_to_use
  local backend_cmd_to_use
  local chat_cmd_to_use

  if ! load_launcher_config; then
    log ERROR "Launcher config not found: ${CONFIG_FILE}"
    log INFO "Run init first: ${0} init --gui"
    exit 23
  fi

  delay_to_use="${STARTUP_DELAY}"
  if [ -n "${STARTUP_DELAY_CFG:-}" ] && [ "${STARTUP_DELAY}" = "2" ]; then
    delay_to_use="${STARTUP_DELAY_CFG}"
  fi

  if ! printf '%s' "${delay_to_use}" | grep -Eq '^[0-9]+$'; then
    delay_to_use="2"
  fi

  runtime_mode_to_use="${RUNTIME_MODE_CFG:-portable}"
  if [ "${RUNTIME_MODE_CLI_SET}" -eq 1 ]; then
    runtime_mode_to_use="${RUNTIME_MODE}"
  fi
  runtime_wrapper_to_use="${RUNTIME_WRAPPER_CFG:-}"
  if [ -z "${runtime_wrapper_to_use}" ] && [ -n "${RUNTIME_WRAPPER_PATH:-}" ]; then
    runtime_wrapper_to_use="${RUNTIME_WRAPPER_PATH}"
  fi
  if [ -z "${runtime_wrapper_to_use}" ] && load_runtime_state; then
    runtime_wrapper_to_use="${RUNTIME_WRAPPER_PATH:-${RUNTIME_WRAPPER_CFG:-}}"
  fi

  backend_cmd_to_use="${BACKEND_CMD}"
  chat_cmd_to_use="${CHAT_CMD}"
  if [ "${runtime_mode_to_use}" = "portable" ]; then
    if [ -z "${runtime_wrapper_to_use}" ] || [ ! -x "${runtime_wrapper_to_use}" ]; then
      log ERROR "Portable runtime wrapper is missing. Run init first or pass --runtime-mode system."
      exit 25
    fi
    backend_cmd_to_use="$(build_runtime_wrapped_command "${runtime_wrapper_to_use}" "${BACKEND_CMD}")"
    chat_cmd_to_use="$(build_runtime_wrapped_command "${runtime_wrapper_to_use}" "${CHAT_CMD}")"
  fi

  write_state "${SESSION_FILE}" "S60_START_STACK" "running" "starting-backend-chat"
  log INFO "Starting stack from config: ${CONFIG_FILE} (runtime_mode=${runtime_mode_to_use})"

  start_component "backend" "${BACKEND_CWD}" "${backend_cmd_to_use}"

  if [ "${DRY_RUN}" -eq 0 ] && [ "${delay_to_use}" -gt 0 ]; then
    sleep "${delay_to_use}"
  fi

  start_component "chat" "${CHAT_CWD}" "${chat_cmd_to_use}"

  write_state "${SESSION_FILE}" "S60_START_STACK" "success" "stack-started"
  log INFO "Stack startup finished"
}

run_stop_stack() {
  write_state "${SESSION_FILE}" "S61_STOP_STACK" "running" "stopping-backend-chat"
  stop_component "chat"
  stop_component "backend"
  write_state "${SESSION_FILE}" "S61_STOP_STACK" "success" "stack-stopped"
}

run_status() {
  local runtime_mode_to_show="portable"
  local runtime_wrapper_to_show=""
  local runtime_manifest_to_show=""
  local runtime_health="missing"

  if [ -f "${CONFIG_FILE}" ]; then
    # shellcheck disable=SC1090
    source "${CONFIG_FILE}"
    printf 'Config: %s\n' "${CONFIG_FILE}"
    printf 'Workspace: %s\n' "${WORKSPACE_ROOT:-<unset>}"
    runtime_mode_to_show="${RUNTIME_MODE_CFG:-portable}"
    runtime_wrapper_to_show="${RUNTIME_WRAPPER_CFG:-}"
    runtime_manifest_to_show="${RUNTIME_MANIFEST_CFG:-}"
  else
    printf 'Config: <not initialized>\n'
  fi

  if [ -z "${runtime_wrapper_to_show}" ] && load_runtime_state; then
    runtime_wrapper_to_show="${RUNTIME_WRAPPER_PATH:-${runtime_wrapper_to_show}}"
    runtime_manifest_to_show="${RUNTIME_MANIFEST_SOURCE:-${runtime_manifest_to_show}}"
  fi
  if [ "${runtime_mode_to_show}" = "system" ]; then
    runtime_health="n/a"
  elif [ -n "${runtime_wrapper_to_show}" ] && [ -x "${runtime_wrapper_to_show}" ]; then
    runtime_health="ready"
  else
    runtime_health="missing"
  fi

  printf 'RuntimeMode: %s\n' "${runtime_mode_to_show}"
  printf 'RuntimeWrapper: %s\n' "${runtime_wrapper_to_show:-<unset>}"
  printf 'RuntimeManifest: %s\n' "${runtime_manifest_to_show:-<unset>}"
  printf 'RuntimeHealth: %s\n' "${runtime_health}"

  show_component_status "backend"
  show_component_status "chat"
}

run_reset() {
  if [ "${DRY_RUN}" -eq 1 ]; then
    if [ "${RESET_RUNTIME}" -eq 1 ]; then
      log INFO "Dry-run: would remove launcher config, pid files, and runtime under ${INSTALLER_HOME}"
    else
      log INFO "Dry-run: would remove launcher config and runtime state under ${INSTALLER_HOME}"
    fi
    return
  fi

  rm -f "${CONFIG_FILE}" "${RUN_DIR}"/*.pid
  rm -f "${STATE_DIR}/init-session-"*.env 2>/dev/null || true
  if [ "${RESET_RUNTIME}" -eq 1 ]; then
    rm -rf "${RUNTIME_ROOT}"
  fi
  log INFO "Reset completed. Config and pid files removed."
}

run_resume() {
  local last_step
  last_step="$(read_state_json_field "${SESSION_FILE}" "step_id")"

  case "${last_step}" in
    S20_INITIALIZE|S25_RUNTIME_PLAN|S26_RUNTIME_FETCH|S27_RUNTIME_VERIFY|S28_RUNTIME_PREPARE)
      if ! load_init_profile_snapshot; then
        log ERROR "Cannot resume init/runtime flow: missing init snapshot ($(runtime_init_profile_file))."
        log INFO "Run init again with explicit args."
        exit 32
      fi
      INIT_RESUME_MODE=1
      log INFO "Resuming init/runtime flow from step ${last_step}"
      run_init
      if [ "${NO_START_AFTER_INIT}" -eq 0 ]; then
        run_start_stack
      fi
      ;;
    *)
      run_install_flow "${SESSION_FILE}"
      ;;
  esac
}

while [ $# -gt 0 ]; do
  case "$1" in
    install|resume|init|start|stop|status|reset)
      COMMAND="$1"
      shift
      ;;
    --cli)
      MODE="cli"
      shift
      ;;
    --gui)
      MODE="gui"
      shift
      ;;
    --auto)
      MODE="auto"
      shift
      ;;
    --headless)
      HEADLESS=1
      shift
      ;;
    --dry-run)
      DRY_RUN=1
      shift
      ;;
    --yes|--non-interactive)
      AUTO_APPROVE=1
      shift
      ;;
    --simulate-gui-step)
      SIMULATE_GUI_STEP=1
      shift
      ;;
    --no-start-after-init)
      NO_START_AFTER_INIT=1
      shift
      ;;
    --runtime-mode)
      RUNTIME_MODE="${2:-}"
      RUNTIME_MODE_CLI_SET=1
      shift 2
      ;;
    --runtime-manifest)
      RUNTIME_MANIFEST_ARG="${2:-}"
      shift 2
      ;;
    --allow-system-integration)
      ALLOW_SYSTEM_INTEGRATION=1
      shift
      ;;
    --reset-runtime)
      RESET_RUNTIME=1
      shift
      ;;
    --workspace-root)
      WORKSPACE_ROOT_ARG="${2:-}"
      shift 2
      ;;
    --components)
      INSTALL_COMPONENTS_ARG="${2:-}"
      shift 2
      ;;
    --skip-node-install)
      SKIP_NODE_INSTALL=1
      shift
      ;;
    --skip-python-install)
      SKIP_PYTHON_INSTALL=1
      shift
      ;;
    --install-plugin-python-deps)
      INSTALL_PLUGIN_PYTHON_DEPS=1
      shift
      ;;
    --install-plugin-manifest-deps)
      INSTALL_PLUGIN_MANIFEST_DEPS=1
      shift
      ;;
    --strict-dependencies)
      STRICT_DEPENDENCIES=1
      shift
      ;;
    --overwrite-config)
      FORCE_CONFIG_REWRITE=1
      shift
      ;;
    --start-after-install)
      START_AFTER_INSTALL=1
      shift
      ;;
    --vcp-api-url)
      VCP_API_URL_ARG="${2:-}"
      shift 2
      ;;
    --vcp-api-key)
      VCP_API_KEY_ARG="${2:-}"
      shift 2
      ;;
    --vcp-port)
      VCP_PORT_ARG="${2:-}"
      shift 2
      ;;
    --vcp-key)
      VCP_KEY_ARG="${2:-}"
      shift 2
      ;;
    --admin-user)
      ADMIN_USER_ARG="${2:-}"
      shift 2
      ;;
    --admin-password)
      ADMIN_PASSWORD_ARG="${2:-}"
      shift 2
      ;;
    --chat-server-url)
      CHAT_SERVER_URL_ARG="${2:-}"
      shift 2
      ;;
    --chat-api-key)
      CHAT_API_KEY_ARG="${2:-}"
      shift 2
      ;;
    --chat-log-url)
      CHAT_LOG_URL_ARG="${2:-}"
      shift 2
      ;;
    --chat-log-key)
      CHAT_LOG_KEY_ARG="${2:-}"
      shift 2
      ;;
    --backend-cwd)
      BACKEND_CWD_ARG="${2:-}"
      shift 2
      ;;
    --backend-cmd)
      BACKEND_CMD_ARG="${2:-}"
      shift 2
      ;;
    --chat-cwd)
      CHAT_CWD_ARG="${2:-}"
      shift 2
      ;;
    --chat-cmd)
      CHAT_CMD_ARG="${2:-}"
      shift 2
      ;;
    --startup-delay)
      STARTUP_DELAY="${2:-}"
      shift 2
      ;;
    --version)
      echo "${VERSION}"
      exit 0
      ;;
    --help|-h)
      usage
      exit 0
      ;;
    *)
      echo "Unknown argument: $1" >&2
      usage >&2
      exit 2
      ;;
  esac
done

if [ "${HEADLESS}" -eq 1 ] && [ "${MODE}" = "gui" ]; then
  echo "Invalid arguments: --headless cannot be combined with --gui" >&2
  exit 2
fi

if [ "${MODE}" = "auto" ]; then
  if [ "${HEADLESS}" -eq 1 ]; then
    MODE="cli"
  elif [ -n "${DISPLAY:-}" ]; then
    MODE="gui"
  else
    MODE="cli"
  fi
fi

if [ "${HEADLESS}" -eq 1 ]; then
  MODE="cli"
fi

validate_vcp_port
if ! validate_runtime_mode; then
  exit 2
fi

if [ "${COMMAND}" = "auto" ]; then
  if [ "${DRY_RUN}" -eq 1 ] || [ "${SIMULATE_GUI_STEP}" -eq 1 ]; then
    COMMAND="install"
  elif [ -f "${CONFIG_FILE}" ]; then
    COMMAND="start"
  else
    COMMAND="init"
  fi
fi

if [ "${COMMAND}" = "resume" ]; then
  latest_session="$(ls -1t "${STATE_DIR}"/session-*.json 2>/dev/null | head -n 1 || true)"
  if [ -z "${latest_session}" ]; then
    echo "No previous session found in ${STATE_DIR}" >&2
    exit 3
  fi
  SESSION_FILE="${latest_session}"
  SESSION_ID="$(basename "${SESSION_FILE}" .json)"
  SESSION_ID="${SESSION_ID#session-}"
  log INFO "Resuming session ${SESSION_ID}"
else
  SESSION_ID="${VCP_INSTALLER_SESSION_ID:-$(date -u +%Y%m%dT%H%M%SZ)}"
  SESSION_FILE="${STATE_DIR}/session-${SESSION_ID}.json"
  log INFO "Starting new session ${SESSION_ID}"
fi

if [ "${AUTO_APPROVE}" -eq 1 ]; then
  log INFO "Non-interactive mode enabled."
fi

log INFO "Mode: ${MODE} (headless=${HEADLESS}, dry_run=${DRY_RUN}, command=${COMMAND})"

case "${COMMAND}" in
  install)
    run_install_flow "${SESSION_FILE}"
    ;;
  resume)
    run_resume
    ;;
  init)
    run_init
    if [ "${NO_START_AFTER_INIT}" -eq 0 ]; then
      run_start_stack
    fi
    ;;
  start)
    run_start_stack
    ;;
  stop)
    run_stop_stack
    ;;
  status)
    run_status
    ;;
  reset)
    run_reset
    ;;
  *)
    echo "Unsupported command: ${COMMAND}" >&2
    exit 2
    ;;
esac
