#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "${SCRIPT_DIR}/.." && pwd)"
VERSION="0.0.0-dev"

for version_path in \
  "${ROOT_DIR}/VERSION" \
  "${SCRIPT_DIR}/../share/vcp-installer/VERSION"; do
  if [ -f "${version_path}" ]; then
    VERSION="$(tr -d '[:space:]' < "${version_path}")"
    break
  fi
done

MODE="auto"
HEADLESS=0
DRY_RUN=0
AUTO_APPROVE=0
SIMULATE_GUI_STEP=0
NO_START_AFTER_INIT=0
STARTUP_DELAY="2"

WORKSPACE_ROOT_ARG=""
BACKEND_CWD_ARG=""
BACKEND_CMD_ARG=""
CHAT_CWD_ARG=""
CHAT_CMD_ARG=""

WORKSPACE_ROOT_VAL=""
BACKEND_CWD_VAL=""
BACKEND_CMD_VAL=""
CHAT_CWD_VAL=""
CHAT_CMD_VAL=""

COMMAND="auto"
SESSION_ID=""
SESSION_FILE=""

resolve_installer_home() {
  if [ -n "${VCP_INSTALLER_HOME:-}" ]; then
    printf '%s\n' "${VCP_INSTALLER_HOME}"
    return
  fi

  if [ -n "${XDG_DATA_HOME:-}" ]; then
    printf '%s/vcpinstallergui\n' "${XDG_DATA_HOME}"
    return
  fi

  if [ -n "${HOME:-}" ]; then
    printf '%s/.local/share/vcpinstallergui\n' "${HOME}"
    return
  fi

  printf '%s/.vcpinstallergui\n' "${ROOT_DIR}"
}

INSTALLER_HOME="$(resolve_installer_home)"
STATE_DIR="${VCP_INSTALLER_STATE_DIR:-${INSTALLER_HOME}/state}"
CONFIG_FILE="${INSTALLER_HOME}/launcher-config.env"
RUN_DIR="${INSTALLER_HOME}/run"
LOG_DIR="${INSTALLER_HOME}/logs"

mkdir -p "${INSTALLER_HOME}" "${STATE_DIR}" "${RUN_DIR}" "${LOG_DIR}"

timestamp() {
  date -u +"%Y-%m-%dT%H:%M:%SZ"
}

log() {
  local level="$1"
  shift
  printf '%s [%s] %s\n' "$(timestamp)" "${level}" "$*"
}

usage() {
  cat <<'EOF'
VCPInstallerGUI installer

Usage:
  vcp-installer [command] [options]

Commands:
  init                    Run initialization wizard and save launch config
  start                   Start backend and VCPChat with saved config
  stop                    Stop backend and VCPChat started by installer
  status                  Show launcher and process status
  reset                   Remove saved launcher config and runtime state
  install                 Run minimal install baseline flow (legacy)
  resume                  Resume previous install baseline session (legacy)

Options:
  --cli                   Force CLI mode
  --gui                   Force GUI mode
  --auto                  Auto detect mode (default)
  --headless              Headless mode (CLI only)
  --dry-run               Do not run mutation steps
  --yes                   Non-interactive mode
  --simulate-gui-step     Simulate a GUI required step (for testing)
  --no-start-after-init   Initialize only, do not auto-start services
  --workspace-root <dir>  Workspace root path (for init)
  --backend-cwd <dir>     Backend working directory
  --backend-cmd <cmd>     Backend startup command
  --chat-cwd <dir>        VCPChat working directory
  --chat-cmd <cmd>        VCPChat startup command
  --startup-delay <sec>   Delay between backend and chat startup
  --version               Print installer version
  --help                  Print this help

Examples:
  vcp-installer
  vcp-installer init --gui
  vcp-installer init --cli --yes --workspace-root ~/vcp --backend-cmd "npm run dev" --chat-cmd "npm run start"
  vcp-installer start
  vcp-installer stop
  vcp-installer status
EOF
}

require_cmd_or_warn() {
  local cmd="$1"
  if command -v "${cmd}" >/dev/null 2>&1; then
    local line
    line="$("${cmd}" --version 2>/dev/null | head -n 1 || true)"
    if [ -n "${line}" ]; then
      log INFO "Detected ${cmd}: ${line}"
    else
      log INFO "Detected ${cmd}"
    fi
  else
    log WARN "Missing dependency: ${cmd}"
  fi
}

emit_gui_required_block() {
  cat <<EOF
GUI_REQUIRED
step_id: S45_GUI_REQUIRED
reason: This step requires an interactive GUI action.
user_action: Open GUI session and complete the required dialog.
completion_criteria: GUI action finished and confirmed.
resume_command: ${0} resume --cli
EOF
}

emit_init_required_block() {
  cat <<EOF
INIT_REQUIRED
step_id: S20_INITIALIZE
reason: Launcher config is missing and headless mode cannot open GUI wizard.
user_action: Run initialization with explicit commands.
completion_criteria: ${CONFIG_FILE} exists with backend/chat commands.
continue_command: ${0} init --cli --yes --backend-cwd <dir> --backend-cmd <cmd> --chat-cwd <dir> --chat-cmd <cmd>
EOF
}

write_state() {
  local session_file="$1"
  local step_id="$2"
  local status="$3"
  local detail="$4"
  cat > "${session_file}" <<EOF
{
  "session_id": "${SESSION_ID}",
  "mode": "${MODE}",
  "headless": ${HEADLESS},
  "dry_run": ${DRY_RUN},
  "step_id": "${step_id}",
  "status": "${status}",
  "detail": "${detail}",
  "updated_at": "$(timestamp)"
}
EOF
}

safe_pid_running() {
  local pid="$1"
  if [ -z "${pid}" ]; then
    return 1
  fi
  kill -0 "${pid}" >/dev/null 2>&1
}

detect_workspace_root() {
  if [ -n "${WORKSPACE_ROOT_ARG}" ]; then
    printf '%s\n' "${WORKSPACE_ROOT_ARG}"
    return
  fi

  if [ -n "${VCP_WORKSPACE_ROOT:-}" ]; then
    printf '%s\n' "${VCP_WORKSPACE_ROOT}"
    return
  fi

  local candidate
  candidate="$(cd "${ROOT_DIR}/.." && pwd)"
  if [ -d "${candidate}/VCPToolBox" ] || [ -d "${candidate}/VCPChat" ]; then
    printf '%s\n' "${candidate}"
    return
  fi

  if [ -n "${HOME:-}" ]; then
    printf '%s/vcp\n' "${HOME}"
    return
  fi

  printf '%s\n' "${ROOT_DIR}"
}

save_launcher_config() {
  local workspace_root="$1"
  local backend_cwd="$2"
  local backend_cmd="$3"
  local chat_cwd="$4"
  local chat_cmd="$5"
  local startup_delay="$6"

  if [ "${DRY_RUN}" -eq 1 ]; then
    log INFO "Dry-run: skip writing launcher config (${CONFIG_FILE})"
    return
  fi

  {
    printf '# Generated by vcp-installer at %s\n' "$(timestamp)"
    printf 'CONFIG_VERSION=%q\n' "1"
    printf 'INITIALIZED_AT=%q\n' "$(timestamp)"
    printf 'WORKSPACE_ROOT=%q\n' "${workspace_root}"
    printf 'BACKEND_CWD=%q\n' "${backend_cwd}"
    printf 'BACKEND_CMD=%q\n' "${backend_cmd}"
    printf 'CHAT_CWD=%q\n' "${chat_cwd}"
    printf 'CHAT_CMD=%q\n' "${chat_cmd}"
    printf 'STARTUP_DELAY_CFG=%q\n' "${startup_delay}"
  } > "${CONFIG_FILE}"

  chmod 600 "${CONFIG_FILE}"
}

load_launcher_config() {
  if [ ! -f "${CONFIG_FILE}" ]; then
    return 1
  fi

  # shellcheck disable=SC1090
  source "${CONFIG_FILE}"

  if [ -z "${BACKEND_CWD:-}" ] || [ -z "${BACKEND_CMD:-}" ] || [ -z "${CHAT_CWD:-}" ] || [ -z "${CHAT_CMD:-}" ]; then
    log ERROR "Launcher config is incomplete: ${CONFIG_FILE}"
    return 2
  fi

  return 0
}

prompt_cli_value() {
  local prompt="$1"
  local default_value="$2"
  local input=""

  read -r -p "${prompt} [${default_value}]: " input || true
  if [ -z "${input}" ]; then
    printf '%s\n' "${default_value}"
  else
    printf '%s\n' "${input}"
  fi
}

collect_init_values() {
  local default_workspace
  local default_backend_cwd
  local default_backend_cmd
  local default_chat_cwd
  local default_chat_cmd

  default_workspace="$(detect_workspace_root)"
  default_backend_cwd="${default_workspace}/VCPToolBox"
  default_backend_cmd="npm run start"
  default_chat_cwd="${default_workspace}/VCPChat"
  default_chat_cmd="npm run start"

  WORKSPACE_ROOT_VAL="${WORKSPACE_ROOT_ARG:-${default_workspace}}"
  BACKEND_CWD_VAL="${BACKEND_CWD_ARG:-${default_backend_cwd}}"
  BACKEND_CMD_VAL="${BACKEND_CMD_ARG:-${default_backend_cmd}}"
  CHAT_CWD_VAL="${CHAT_CWD_ARG:-${default_chat_cwd}}"
  CHAT_CMD_VAL="${CHAT_CMD_ARG:-${default_chat_cmd}}"

  if [ "${HEADLESS}" -eq 1 ] && [ "${AUTO_APPROVE}" -eq 0 ]; then
    emit_init_required_block
    exit 31
  fi

  if [ "${AUTO_APPROVE}" -eq 1 ]; then
    return
  fi

  if [ "${MODE}" = "gui" ] && [ -n "${DISPLAY:-}" ] && command -v zenity >/dev/null 2>&1; then
    local sep=$'\x1f'
    local form_output

    form_output="$(zenity --forms \
      --title="VCP Installer Initialization" \
      --text="Set startup profile for backend and VCPChat." \
      --separator="${sep}" \
      --add-entry="Workspace Root" \
      --add-entry="Backend Working Directory" \
      --add-entry="Backend Start Command" \
      --add-entry="VCPChat Working Directory" \
      --add-entry="VCPChat Start Command" \
      --add-entry="Startup Delay Seconds")"

    if [ -z "${form_output}" ]; then
      log WARN "Initialization wizard cancelled."
      exit 4
    fi

    IFS="${sep}" read -r WORKSPACE_ROOT_VAL BACKEND_CWD_VAL BACKEND_CMD_VAL CHAT_CWD_VAL CHAT_CMD_VAL STARTUP_DELAY_FORM <<< "${form_output}"
    if [ -n "${STARTUP_DELAY_FORM:-}" ]; then
      STARTUP_DELAY="${STARTUP_DELAY_FORM}"
    fi
  else
    WORKSPACE_ROOT_VAL="$(prompt_cli_value "Workspace root" "${WORKSPACE_ROOT_VAL}")"
    BACKEND_CWD_VAL="$(prompt_cli_value "Backend working directory" "${BACKEND_CWD_VAL}")"
    BACKEND_CMD_VAL="$(prompt_cli_value "Backend start command" "${BACKEND_CMD_VAL}")"
    CHAT_CWD_VAL="$(prompt_cli_value "VCPChat working directory" "${CHAT_CWD_VAL}")"
    CHAT_CMD_VAL="$(prompt_cli_value "VCPChat start command" "${CHAT_CMD_VAL}")"
    STARTUP_DELAY="$(prompt_cli_value "Startup delay seconds" "${STARTUP_DELAY}")"
  fi
}

validate_startup_delay() {
  if ! printf '%s' "${STARTUP_DELAY}" | grep -Eq '^[0-9]+$'; then
    echo "Invalid --startup-delay: ${STARTUP_DELAY}" >&2
    exit 2
  fi
}

start_component() {
  local name="$1"
  local cwd="$2"
  local cmd="$3"
  local pid_file="${RUN_DIR}/${name}.pid"
  local log_file="${LOG_DIR}/${name}.log"

  if [ -f "${pid_file}" ]; then
    local existing_pid
    existing_pid="$(cat "${pid_file}" 2>/dev/null || true)"
    if safe_pid_running "${existing_pid}"; then
      log INFO "${name} already running (pid=${existing_pid})."
      return 0
    fi
    rm -f "${pid_file}"
  fi

  if [ ! -d "${cwd}" ]; then
    log ERROR "${name} working directory not found: ${cwd}"
    return 21
  fi

  if [ "${DRY_RUN}" -eq 1 ]; then
    log INFO "Dry-run: would start ${name}"
    log INFO "  cwd=${cwd}"
    log INFO "  cmd=${cmd}"
    return 0
  fi

  (
    cd "${cwd}"
    nohup bash -lc "${cmd}" >> "${log_file}" 2>&1 &
    echo $! > "${pid_file}"
  )

  local new_pid
  new_pid="$(cat "${pid_file}")"
  log INFO "${name} started (pid=${new_pid})"
  log INFO "${name} log file: ${log_file}"
}

stop_component() {
  local name="$1"
  local pid_file="${RUN_DIR}/${name}.pid"

  if [ ! -f "${pid_file}" ]; then
    log INFO "${name} is not running (no pid file)."
    return 0
  fi

  local pid
  pid="$(cat "${pid_file}" 2>/dev/null || true)"

  if ! safe_pid_running "${pid}"; then
    rm -f "${pid_file}"
    log INFO "${name} pid was stale; cleaned pid file."
    return 0
  fi

  if [ "${DRY_RUN}" -eq 1 ]; then
    log INFO "Dry-run: would stop ${name} (pid=${pid})"
    return 0
  fi

  kill "${pid}" 2>/dev/null || true

  local i
  for i in 1 2 3 4 5 6 7 8 9 10; do
    if safe_pid_running "${pid}"; then
      sleep 0.3
    else
      break
    fi
  done

  if safe_pid_running "${pid}"; then
    kill -9 "${pid}" 2>/dev/null || true
  fi

  rm -f "${pid_file}"
  log INFO "${name} stopped"
}

show_component_status() {
  local name="$1"
  local pid_file="${RUN_DIR}/${name}.pid"

  if [ ! -f "${pid_file}" ]; then
    printf '%s: STOPPED\n' "${name}"
    return
  fi

  local pid
  pid="$(cat "${pid_file}" 2>/dev/null || true)"
  if safe_pid_running "${pid}"; then
    printf '%s: RUNNING (pid=%s)\n' "${name}" "${pid}"
  else
    printf '%s: STOPPED (stale pid file)\n' "${name}"
  fi
}

run_flow() {
  local session_file="$1"

  write_state "${session_file}" "S00_PRECHECK" "running" "precheck-started"
  log INFO "Step S00_PRECHECK: validating runtime dependencies"
  require_cmd_or_warn git
  require_cmd_or_warn node
  require_cmd_or_warn npm
  require_cmd_or_warn python3

  write_state "${session_file}" "S10_WORKSPACE" "running" "workspace-detection"
  log INFO "Step S10_WORKSPACE: root path ${ROOT_DIR}"

  if [ "${SIMULATE_GUI_STEP}" -eq 1 ]; then
    write_state "${session_file}" "S45_GUI_REQUIRED" "blocked" "gui-required-step"
    if [ "${HEADLESS}" -eq 1 ]; then
      emit_gui_required_block
      exit 30
    fi

    if [ "${MODE}" = "gui" ] && [ -n "${DISPLAY:-}" ] && command -v zenity >/dev/null 2>&1; then
      zenity --info --title "VCP Installer" --text "GUI required step simulated. Click OK to continue." || true
    else
      log WARN "GUI required step simulated without zenity; continuing in non-interactive fallback."
    fi
  fi

  write_state "${session_file}" "S50_INSTALL" "running" "install-orchestration"
  if [ "${DRY_RUN}" -eq 1 ]; then
    log INFO "Step S50_INSTALL: dry-run enabled, no changes will be made."
  else
    log INFO "Step S50_INSTALL: minimal baseline implementation (no component mutation yet)."
  fi

  write_state "${session_file}" "S70_REPORT" "success" "completed"
  log INFO "Step S70_REPORT: flow completed successfully"
  log INFO "State file: ${session_file}"
}

run_init() {
  write_state "${SESSION_FILE}" "S20_INITIALIZE" "running" "collect-launch-profile"
  collect_init_values
  validate_startup_delay

  if [ -z "${BACKEND_CMD_VAL}" ] || [ -z "${CHAT_CMD_VAL}" ]; then
    log ERROR "Initialization failed: backend/chat command cannot be empty"
    write_state "${SESSION_FILE}" "S20_INITIALIZE" "failed" "empty-command"
    exit 22
  fi

  save_launcher_config \
    "${WORKSPACE_ROOT_VAL}" \
    "${BACKEND_CWD_VAL}" \
    "${BACKEND_CMD_VAL}" \
    "${CHAT_CWD_VAL}" \
    "${CHAT_CMD_VAL}" \
    "${STARTUP_DELAY}"

  log INFO "Initialization completed. Config: ${CONFIG_FILE}"
  write_state "${SESSION_FILE}" "S20_INITIALIZE" "success" "config-saved"
}

run_start_stack() {
  if ! load_launcher_config; then
    log ERROR "Launcher config not found: ${CONFIG_FILE}"
    log INFO "Run init first: ${0} init --gui"
    exit 23
  fi

  local delay_to_use="${STARTUP_DELAY}"
  if [ -n "${STARTUP_DELAY_CFG:-}" ] && [ "${STARTUP_DELAY}" = "2" ]; then
    delay_to_use="${STARTUP_DELAY_CFG}"
  fi

  if ! printf '%s' "${delay_to_use}" | grep -Eq '^[0-9]+$'; then
    delay_to_use="2"
  fi

  write_state "${SESSION_FILE}" "S60_START_STACK" "running" "starting-backend-chat"
  log INFO "Starting stack from config: ${CONFIG_FILE}"

  start_component "backend" "${BACKEND_CWD}" "${BACKEND_CMD}"

  if [ "${DRY_RUN}" -eq 0 ] && [ "${delay_to_use}" -gt 0 ]; then
    sleep "${delay_to_use}"
  fi

  start_component "chat" "${CHAT_CWD}" "${CHAT_CMD}"

  write_state "${SESSION_FILE}" "S60_START_STACK" "success" "stack-started"
  log INFO "Stack startup finished"
}

run_stop_stack() {
  write_state "${SESSION_FILE}" "S61_STOP_STACK" "running" "stopping-backend-chat"
  stop_component "chat"
  stop_component "backend"
  write_state "${SESSION_FILE}" "S61_STOP_STACK" "success" "stack-stopped"
}

run_status() {
  if [ -f "${CONFIG_FILE}" ]; then
    # shellcheck disable=SC1090
    source "${CONFIG_FILE}"
    printf 'Config: %s\n' "${CONFIG_FILE}"
    printf 'Workspace: %s\n' "${WORKSPACE_ROOT:-<unset>}"
  else
    printf 'Config: <not initialized>\n'
  fi

  show_component_status "backend"
  show_component_status "chat"
}

run_reset() {
  if [ "${DRY_RUN}" -eq 1 ]; then
    log INFO "Dry-run: would remove launcher config and runtime state under ${INSTALLER_HOME}"
    return
  fi

  rm -f "${CONFIG_FILE}" "${RUN_DIR}"/*.pid
  log INFO "Reset completed. Config and pid files removed."
}

while [ $# -gt 0 ]; do
  case "$1" in
    install|resume|init|start|stop|status|reset)
      COMMAND="$1"
      shift
      ;;
    --cli)
      MODE="cli"
      shift
      ;;
    --gui)
      MODE="gui"
      shift
      ;;
    --auto)
      MODE="auto"
      shift
      ;;
    --headless)
      HEADLESS=1
      shift
      ;;
    --dry-run)
      DRY_RUN=1
      shift
      ;;
    --yes|--non-interactive)
      AUTO_APPROVE=1
      shift
      ;;
    --simulate-gui-step)
      SIMULATE_GUI_STEP=1
      shift
      ;;
    --no-start-after-init)
      NO_START_AFTER_INIT=1
      shift
      ;;
    --workspace-root)
      WORKSPACE_ROOT_ARG="${2:-}"
      shift 2
      ;;
    --backend-cwd)
      BACKEND_CWD_ARG="${2:-}"
      shift 2
      ;;
    --backend-cmd)
      BACKEND_CMD_ARG="${2:-}"
      shift 2
      ;;
    --chat-cwd)
      CHAT_CWD_ARG="${2:-}"
      shift 2
      ;;
    --chat-cmd)
      CHAT_CMD_ARG="${2:-}"
      shift 2
      ;;
    --startup-delay)
      STARTUP_DELAY="${2:-}"
      shift 2
      ;;
    --version)
      echo "${VERSION}"
      exit 0
      ;;
    --help|-h)
      usage
      exit 0
      ;;
    *)
      echo "Unknown argument: $1" >&2
      usage >&2
      exit 2
      ;;
  esac
done

if [ "${HEADLESS}" -eq 1 ] && [ "${MODE}" = "gui" ]; then
  echo "Invalid arguments: --headless cannot be combined with --gui" >&2
  exit 2
fi

if [ "${MODE}" = "auto" ]; then
  if [ "${HEADLESS}" -eq 1 ]; then
    MODE="cli"
  elif [ -n "${DISPLAY:-}" ]; then
    MODE="gui"
  else
    MODE="cli"
  fi
fi

if [ "${HEADLESS}" -eq 1 ]; then
  MODE="cli"
fi

if [ "${COMMAND}" = "auto" ]; then
  if [ "${DRY_RUN}" -eq 1 ] || [ "${SIMULATE_GUI_STEP}" -eq 1 ]; then
    COMMAND="install"
  elif [ -f "${CONFIG_FILE}" ]; then
    COMMAND="start"
  else
    COMMAND="init"
  fi
fi

if [ "${COMMAND}" = "resume" ]; then
  latest_session="$(ls -1t "${STATE_DIR}"/session-*.json 2>/dev/null | head -n 1 || true)"
  if [ -z "${latest_session}" ]; then
    echo "No previous session found in ${STATE_DIR}" >&2
    exit 3
  fi
  SESSION_FILE="${latest_session}"
  SESSION_ID="$(basename "${SESSION_FILE}" .json)"
  SESSION_ID="${SESSION_ID#session-}"
  log INFO "Resuming session ${SESSION_ID}"
else
  SESSION_ID="${VCP_INSTALLER_SESSION_ID:-$(date -u +%Y%m%dT%H%M%SZ)}"
  SESSION_FILE="${STATE_DIR}/session-${SESSION_ID}.json"
  log INFO "Starting new session ${SESSION_ID}"
fi

if [ "${AUTO_APPROVE}" -eq 1 ]; then
  log INFO "Non-interactive mode enabled."
fi

log INFO "Mode: ${MODE} (headless=${HEADLESS}, dry_run=${DRY_RUN}, command=${COMMAND})"

case "${COMMAND}" in
  install|resume)
    run_flow "${SESSION_FILE}"
    ;;
  init)
    run_init
    if [ "${NO_START_AFTER_INIT}" -eq 0 ]; then
      run_start_stack
    fi
    ;;
  start)
    run_start_stack
    ;;
  stop)
    run_stop_stack
    ;;
  status)
    run_status
    ;;
  reset)
    run_reset
    ;;
  *)
    echo "Unsupported command: ${COMMAND}" >&2
    exit 2
    ;;
esac
